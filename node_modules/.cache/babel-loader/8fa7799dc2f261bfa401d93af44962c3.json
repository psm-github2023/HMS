{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst errcode = require('err-code');\nconst multihash = require('multihashes');\nconst crypto = require('./crypto');\n\n/**\n * Hash the given `buf` using the algorithm specified by `alg`.\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\nasync function Multihashing(buf, alg, length) {\n  const digest = await Multihashing.digest(buf, alg, length);\n  return multihash.encode(digest, alg, length);\n}\n\n/**\n * The `buffer` module for easy use in the browser.\n *\n * @type {Buffer}\n */\nMultihashing.Buffer = Buffer; // for browser things\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\nMultihashing.multihash = multihash;\n\n/**\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\nMultihashing.digest = async (buf, alg, length) => {\n  const hash = Multihashing.createHash(alg);\n  const digest = await hash(buf);\n  return length ? digest.slice(0, length) : digest;\n};\n\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {string|number} alg - The algorithm to use eg 'sha1'\n *\n * @returns {function} - The hash function corresponding to `alg`\n */\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    throw errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED');\n  }\n  alg = multihash.coerceCode(alg);\n  if (!Multihashing.functions[alg]) {\n    throw errcode(new Error(`multihash function '${alg}' not yet supported`), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED');\n  }\n  return Multihashing.functions[alg];\n};\n\n/**\n * Mapping of multihash codes to their hashing functions.\n * @type {Object}\n */\nMultihashing.functions = {\n  // identity\n  0x00: crypto.identity,\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n};\n\n// add blake functions\ncrypto.addBlake(Multihashing.functions);\nMultihashing.validate = async (buf, hash) => {\n  const newHash = await Multihashing(buf, multihash.decode(hash).name);\n  return Buffer.compare(hash, newHash) === 0;\n};\nmodule.exports = Multihashing;","map":{"version":3,"names":["Buffer","require","errcode","multihash","crypto","Multihashing","buf","alg","length","digest","encode","hash","createHash","slice","Error","coerceCode","functions","identity","sha1","sha2256","sha2512","sha3512","sha3384","sha3256","sha3224","shake128","shake256","keccak224","keccak256","keccak384","keccak512","murmur3128","murmur332","dblSha2256","addBlake","validate","newHash","decode","name","compare","module","exports"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/multihashing-async/src/index.js"],"sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst errcode = require('err-code')\nconst multihash = require('multihashes')\nconst crypto = require('./crypto')\n\n/**\n * Hash the given `buf` using the algorithm specified by `alg`.\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\nasync function Multihashing (buf, alg, length) {\n  const digest = await Multihashing.digest(buf, alg, length)\n  return multihash.encode(digest, alg, length)\n}\n\n/**\n * The `buffer` module for easy use in the browser.\n *\n * @type {Buffer}\n */\nMultihashing.Buffer = Buffer // for browser things\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\nMultihashing.multihash = multihash\n\n/**\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\nMultihashing.digest = async (buf, alg, length) => {\n  const hash = Multihashing.createHash(alg)\n  const digest = await hash(buf)\n  return length ? digest.slice(0, length) : digest\n}\n\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {string|number} alg - The algorithm to use eg 'sha1'\n *\n * @returns {function} - The hash function corresponding to `alg`\n */\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    throw errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED')\n  }\n\n  alg = multihash.coerceCode(alg)\n  if (!Multihashing.functions[alg]) {\n    throw errcode(new Error(`multihash function '${alg}' not yet supported`), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED')\n  }\n\n  return Multihashing.functions[alg]\n}\n\n/**\n * Mapping of multihash codes to their hashing functions.\n * @type {Object}\n */\nMultihashing.functions = {\n  // identity\n  0x00: crypto.identity,\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}\n\n// add blake functions\ncrypto.addBlake(Multihashing.functions)\n\nMultihashing.validate = async (buf, hash) => {\n  const newHash = await Multihashing(buf, multihash.decode(hash).name)\n\n  return Buffer.compare(hash, newHash) === 0\n}\n\nmodule.exports = Multihashing\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}