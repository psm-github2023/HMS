{"ast":null,"code":"'use strict';\n\nvar schema = require('protocol-buffers-schema');\nconst {\n  Buffer\n} = require('buffer');\nvar compile = require('./compile');\nvar flatten = function (values) {\n  if (!values) return null;\n  var result = {};\n  Object.keys(values).forEach(function (k) {\n    result[k] = values[k].value;\n  });\n  return result;\n};\nmodule.exports = function (proto, opts) {\n  if (!opts) opts = {};\n  if (!proto) throw new Error('Pass in a .proto string or a protobuf-schema parsed object');\n  var sch = typeof proto === 'object' && !Buffer.isBuffer(proto) ? proto : schema.parse(proto);\n\n  // to not make toString,toJSON enumarable we make a fire-and-forget prototype\n  var Messages = function () {\n    var self = this;\n    compile(sch, opts.encodings || {}).forEach(function (m) {\n      self[m.name] = flatten(m.values) || m;\n    });\n  };\n  Messages.prototype.toString = function () {\n    return schema.stringify(sch);\n  };\n  Messages.prototype.toJSON = function () {\n    return sch;\n  };\n  return new Messages();\n};","map":{"version":3,"names":["schema","require","Buffer","compile","flatten","values","result","Object","keys","forEach","k","value","module","exports","proto","opts","Error","sch","isBuffer","parse","Messages","self","encodings","m","name","prototype","toString","stringify","toJSON"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/protons/src/index.js"],"sourcesContent":["'use strict'\n\nvar schema = require('protocol-buffers-schema')\nconst { Buffer } = require('buffer')\nvar compile = require('./compile')\n\nvar flatten = function (values) {\n  if (!values) return null\n  var result = {}\n  Object.keys(values).forEach(function (k) {\n    result[k] = values[k].value\n  })\n  return result\n}\n\nmodule.exports = function (proto, opts) {\n  if (!opts) opts = {}\n  if (!proto) throw new Error('Pass in a .proto string or a protobuf-schema parsed object')\n\n  var sch = (typeof proto === 'object' && !Buffer.isBuffer(proto)) ? proto : schema.parse(proto)\n\n  // to not make toString,toJSON enumarable we make a fire-and-forget prototype\n  var Messages = function () {\n    var self = this\n\n    compile(sch, opts.encodings || {}).forEach(function (m) {\n      self[m.name] = flatten(m.values) || m\n    })\n  }\n\n  Messages.prototype.toString = function () {\n    return schema.stringify(sch)\n  }\n\n  Messages.prototype.toJSON = function () {\n    return sch\n  }\n\n  return new Messages()\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,yBAAyB,CAAC;AAC/C,MAAM;EAAEC;AAAO,CAAC,GAAGD,OAAO,CAAC,QAAQ,CAAC;AACpC,IAAIE,OAAO,GAAGF,OAAO,CAAC,WAAW,CAAC;AAElC,IAAIG,OAAO,GAAG,SAAAA,CAAUC,MAAM,EAAE;EAC9B,IAAI,CAACA,MAAM,EAAE,OAAO,IAAI;EACxB,IAAIC,MAAM,GAAG,CAAC,CAAC;EACfC,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC,CAACI,OAAO,CAAC,UAAUC,CAAC,EAAE;IACvCJ,MAAM,CAACI,CAAC,CAAC,GAAGL,MAAM,CAACK,CAAC,CAAC,CAACC,KAAK;EAC7B,CAAC,CAAC;EACF,OAAOL,MAAM;AACf,CAAC;AAEDM,MAAM,CAACC,OAAO,GAAG,UAAUC,KAAK,EAAEC,IAAI,EAAE;EACtC,IAAI,CAACA,IAAI,EAAEA,IAAI,GAAG,CAAC,CAAC;EACpB,IAAI,CAACD,KAAK,EAAE,MAAM,IAAIE,KAAK,CAAC,4DAA4D,CAAC;EAEzF,IAAIC,GAAG,GAAI,OAAOH,KAAK,KAAK,QAAQ,IAAI,CAACZ,MAAM,CAACgB,QAAQ,CAACJ,KAAK,CAAC,GAAIA,KAAK,GAAGd,MAAM,CAACmB,KAAK,CAACL,KAAK,CAAC;;EAE9F;EACA,IAAIM,QAAQ,GAAG,SAAAA,CAAA,EAAY;IACzB,IAAIC,IAAI,GAAG,IAAI;IAEflB,OAAO,CAACc,GAAG,EAAEF,IAAI,CAACO,SAAS,IAAI,CAAC,CAAC,CAAC,CAACb,OAAO,CAAC,UAAUc,CAAC,EAAE;MACtDF,IAAI,CAACE,CAAC,CAACC,IAAI,CAAC,GAAGpB,OAAO,CAACmB,CAAC,CAAClB,MAAM,CAAC,IAAIkB,CAAC;IACvC,CAAC,CAAC;EACJ,CAAC;EAEDH,QAAQ,CAACK,SAAS,CAACC,QAAQ,GAAG,YAAY;IACxC,OAAO1B,MAAM,CAAC2B,SAAS,CAACV,GAAG,CAAC;EAC9B,CAAC;EAEDG,QAAQ,CAACK,SAAS,CAACG,MAAM,GAAG,YAAY;IACtC,OAAOX,GAAG;EACZ,CAAC;EAED,OAAO,IAAIG,QAAQ,CAAC,CAAC;AACvB,CAAC"},"metadata":{},"sourceType":"script"}