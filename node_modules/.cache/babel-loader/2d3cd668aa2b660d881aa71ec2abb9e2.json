{"ast":null,"code":"'use strict';\n\nconst base58 = require('bs58');\nconst multihash = require('multihashes');\nconst multibase = require('multibase');\nconst Multiaddr = require('multiaddr');\nconst mafmt = require('mafmt');\nconst CID = require('cids');\nconst urlPattern = /^https?:\\/\\/[^/]+\\/(ip(f|n)s)\\/((\\w+).*)/;\nconst pathPattern = /^\\/(ip(f|n)s)\\/((\\w+).*)/;\nconst defaultProtocolMatch = 1;\nconst defaultHashMath = 4;\nconst fqdnPattern = /^https?:\\/\\/([^/]+)\\.(ip(?:f|n)s)\\.[^/]+/;\nconst fqdnHashMatch = 1;\nconst fqdnProtocolMatch = 2;\nfunction isMultihash(hash) {\n  const formatted = convertToString(hash);\n  try {\n    const buffer = Buffer.from(base58.decode(formatted));\n    multihash.decode(buffer);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction isMultibase(hash) {\n  try {\n    return multibase.isEncoded(hash);\n  } catch (e) {\n    return false;\n  }\n}\nfunction isCID(hash) {\n  try {\n    new CID(hash); // eslint-disable-line no-new\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction isMultiaddr(input) {\n  if (!input) return false;\n  if (Multiaddr.isMultiaddr(input)) return true;\n  try {\n    new Multiaddr(input); // eslint-disable-line no-new\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction isPeerMultiaddr(input) {\n  return isMultiaddr(input) && mafmt.IPFS.matches(input);\n}\nfunction isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input);\n  if (!formatted) {\n    return false;\n  }\n  const match = formatted.match(pattern);\n  if (!match) {\n    return false;\n  }\n  if (match[protocolMatch] !== 'ipfs') {\n    return false;\n  }\n  let hash = match[hashMatch];\n  if (hash && pattern === fqdnPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    hash = hash.toLowerCase();\n  }\n  return isCID(hash);\n}\nfunction isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch) {\n  const formatted = convertToString(input);\n  if (!formatted) {\n    return false;\n  }\n  const match = formatted.match(pattern);\n  if (!match) {\n    return false;\n  }\n  if (match[protocolMatch] !== 'ipns') {\n    return false;\n  }\n  if (hashMatch && pattern === fqdnPattern) {\n    let hash = match[hashMatch];\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    hash = hash.toLowerCase();\n    return isCID(hash);\n  }\n  return true;\n}\nfunction isString(input) {\n  return typeof input === 'string';\n}\nfunction convertToString(input) {\n  if (Buffer.isBuffer(input)) {\n    return base58.encode(input);\n  }\n  if (isString(input)) {\n    return input;\n  }\n  return false;\n}\nconst ipfsSubdomain = url => isIpfs(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch);\nconst ipnsSubdomain = url => isIpns(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch);\nmodule.exports = {\n  multihash: isMultihash,\n  multiaddr: isMultiaddr,\n  peerMultiaddr: isPeerMultiaddr,\n  cid: isCID,\n  base32cid: cid => isMultibase(cid) === 'base32' && isCID(cid),\n  ipfsSubdomain: ipfsSubdomain,\n  ipnsSubdomain: ipnsSubdomain,\n  subdomain: url => ipfsSubdomain(url) || ipnsSubdomain(url),\n  subdomainPattern: fqdnPattern,\n  ipfsUrl: url => isIpfs(url, urlPattern),\n  ipnsUrl: url => isIpns(url, urlPattern),\n  url: url => isIpfs(url, urlPattern) || isIpns(url, urlPattern),\n  urlPattern: urlPattern,\n  ipfsPath: path => isIpfs(path, pathPattern),\n  ipnsPath: path => isIpns(path, pathPattern),\n  path: path => isIpfs(path, pathPattern) || isIpns(path, pathPattern),\n  pathPattern: pathPattern,\n  urlOrPath: x => isIpfs(x, urlPattern) || isIpns(x, urlPattern) || isIpfs(x, pathPattern) || isIpns(x, pathPattern),\n  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n};","map":{"version":3,"names":["base58","require","multihash","multibase","Multiaddr","mafmt","CID","urlPattern","pathPattern","defaultProtocolMatch","defaultHashMath","fqdnPattern","fqdnHashMatch","fqdnProtocolMatch","isMultihash","hash","formatted","convertToString","buffer","Buffer","from","decode","e","isMultibase","isEncoded","isCID","isMultiaddr","input","isPeerMultiaddr","IPFS","matches","isIpfs","pattern","protocolMatch","hashMatch","match","toLowerCase","isIpns","isString","isBuffer","encode","ipfsSubdomain","url","ipnsSubdomain","module","exports","multiaddr","peerMultiaddr","cid","base32cid","subdomain","subdomainPattern","ipfsUrl","ipnsUrl","ipfsPath","path","ipnsPath","urlOrPath","x","cidPath"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/is-ipfs/src/index.js"],"sourcesContent":["'use strict'\n\nconst base58 = require('bs58')\nconst multihash = require('multihashes')\nconst multibase = require('multibase')\nconst Multiaddr = require('multiaddr')\nconst mafmt = require('mafmt')\nconst CID = require('cids')\n\nconst urlPattern = /^https?:\\/\\/[^/]+\\/(ip(f|n)s)\\/((\\w+).*)/\nconst pathPattern = /^\\/(ip(f|n)s)\\/((\\w+).*)/\nconst defaultProtocolMatch = 1\nconst defaultHashMath = 4\n\nconst fqdnPattern = /^https?:\\/\\/([^/]+)\\.(ip(?:f|n)s)\\.[^/]+/\nconst fqdnHashMatch = 1\nconst fqdnProtocolMatch = 2\n\nfunction isMultihash (hash) {\n  const formatted = convertToString(hash)\n  try {\n    const buffer = Buffer.from(base58.decode(formatted))\n    multihash.decode(buffer)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nfunction isMultibase (hash) {\n  try {\n    return multibase.isEncoded(hash)\n  } catch (e) {\n    return false\n  }\n}\n\nfunction isCID (hash) {\n  try {\n    new CID(hash) // eslint-disable-line no-new\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nfunction isMultiaddr (input) {\n  if (!input) return false\n  if (Multiaddr.isMultiaddr(input)) return true\n  try {\n    new Multiaddr(input) // eslint-disable-line no-new\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nfunction isPeerMultiaddr (input) {\n  return isMultiaddr(input) && mafmt.IPFS.matches(input)\n}\n\nfunction isIpfs (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input)\n  if (!formatted) {\n    return false\n  }\n\n  const match = formatted.match(pattern)\n  if (!match) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false\n  }\n\n  let hash = match[hashMatch]\n\n  if (hash && pattern === fqdnPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    hash = hash.toLowerCase()\n  }\n\n  return isCID(hash)\n}\n\nfunction isIpns (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch) {\n  const formatted = convertToString(input)\n  if (!formatted) {\n    return false\n  }\n  const match = formatted.match(pattern)\n  if (!match) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false\n  }\n\n  if (hashMatch && pattern === fqdnPattern) {\n    let hash = match[hashMatch]\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    hash = hash.toLowerCase()\n    return isCID(hash)\n  }\n\n  return true\n}\n\nfunction isString (input) {\n  return typeof input === 'string'\n}\n\nfunction convertToString (input) {\n  if (Buffer.isBuffer(input)) {\n    return base58.encode(input)\n  }\n\n  if (isString(input)) {\n    return input\n  }\n\n  return false\n}\n\nconst ipfsSubdomain = (url) => isIpfs(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch)\nconst ipnsSubdomain = (url) => isIpns(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch)\n\nmodule.exports = {\n  multihash: isMultihash,\n  multiaddr: isMultiaddr,\n  peerMultiaddr: isPeerMultiaddr,\n  cid: isCID,\n  base32cid: (cid) => (isMultibase(cid) === 'base32' && isCID(cid)),\n  ipfsSubdomain: ipfsSubdomain,\n  ipnsSubdomain: ipnsSubdomain,\n  subdomain: (url) => (ipfsSubdomain(url) || ipnsSubdomain(url)),\n  subdomainPattern: fqdnPattern,\n  ipfsUrl: (url) => isIpfs(url, urlPattern),\n  ipnsUrl: (url) => isIpns(url, urlPattern),\n  url: (url) => (isIpfs(url, urlPattern) || isIpns(url, urlPattern)),\n  urlPattern: urlPattern,\n  ipfsPath: (path) => isIpfs(path, pathPattern),\n  ipnsPath: (path) => isIpns(path, pathPattern),\n  path: (path) => (isIpfs(path, pathPattern) || isIpns(path, pathPattern)),\n  pathPattern: pathPattern,\n  urlOrPath: (x) => (isIpfs(x, urlPattern) || isIpns(x, urlPattern) || isIpfs(x, pathPattern) || isIpns(x, pathPattern)),\n  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}