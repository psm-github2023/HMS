{"ast":null,"code":"'use strict';\n\nconst whilst = require('async/whilst');\nconst hmac = require('../hmac');\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n};\n\n// Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\nmodule.exports = (cipherType, hash, secret, callback) => {\n  const cipher = cipherMap[cipherType];\n  if (!cipher) {\n    return callback(new Error('unkown cipherType passed'));\n  }\n  if (!hash) {\n    return callback(new Error('unkown hashType passed'));\n  }\n  const cipherKeySize = cipher.keySize;\n  const ivSize = cipher.ivSize;\n  const hmacKeySize = 20;\n  const seed = Buffer.from('key expansion');\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n  hmac.create(hash, secret, (err, m) => {\n    if (err) {\n      return callback(err);\n    }\n    m.digest(seed, (err, a) => {\n      if (err) {\n        return callback(err);\n      }\n      const result = [];\n      let j = 0;\n      whilst(() => j < resultLength, stretch, finish);\n      function stretch(cb) {\n        m.digest(Buffer.concat([a, seed]), (err, b) => {\n          if (err) {\n            return cb(err);\n          }\n          let todo = b.length;\n          if (j + todo > resultLength) {\n            todo = resultLength - j;\n          }\n          result.push(b);\n          j += todo;\n          m.digest(a, (err, _a) => {\n            if (err) {\n              return cb(err);\n            }\n            a = _a;\n            cb();\n          });\n        });\n      }\n      function finish(err) {\n        if (err) {\n          return callback(err);\n        }\n        const half = resultLength / 2;\n        const resultBuffer = Buffer.concat(result);\n        const r1 = resultBuffer.slice(0, half);\n        const r2 = resultBuffer.slice(half, resultLength);\n        const createKey = res => ({\n          iv: res.slice(0, ivSize),\n          cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n          macKey: res.slice(ivSize + cipherKeySize)\n        });\n        callback(null, {\n          k1: createKey(r1),\n          k2: createKey(r2)\n        });\n      }\n    });\n  });\n};","map":{"version":3,"names":["whilst","require","hmac","cipherMap","ivSize","keySize","Blowfish","cipherKeySize","module","exports","cipherType","hash","secret","callback","cipher","Error","hmacKeySize","seed","Buffer","from","resultLength","create","err","m","digest","a","result","j","stretch","finish","cb","concat","b","todo","length","push","_a","half","resultBuffer","r1","slice","r2","createKey","res","iv","cipherKey","macKey","k1","k2"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/libp2p-crypto/src/keys/key-stretcher.js"],"sourcesContent":["'use strict'\n\nconst whilst = require('async/whilst')\nconst hmac = require('../hmac')\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}\n\n// Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\nmodule.exports = (cipherType, hash, secret, callback) => {\n  const cipher = cipherMap[cipherType]\n\n  if (!cipher) {\n    return callback(new Error('unkown cipherType passed'))\n  }\n\n  if (!hash) {\n    return callback(new Error('unkown hashType passed'))\n  }\n\n  const cipherKeySize = cipher.keySize\n  const ivSize = cipher.ivSize\n  const hmacKeySize = 20\n  const seed = Buffer.from('key expansion')\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize)\n\n  hmac.create(hash, secret, (err, m) => {\n    if (err) {\n      return callback(err)\n    }\n\n    m.digest(seed, (err, a) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const result = []\n      let j = 0\n\n      whilst(\n        () => j < resultLength,\n        stretch,\n        finish\n      )\n\n      function stretch (cb) {\n        m.digest(Buffer.concat([a, seed]), (err, b) => {\n          if (err) {\n            return cb(err)\n          }\n\n          let todo = b.length\n\n          if (j + todo > resultLength) {\n            todo = resultLength - j\n          }\n\n          result.push(b)\n\n          j += todo\n\n          m.digest(a, (err, _a) => {\n            if (err) {\n              return cb(err)\n            }\n            a = _a\n            cb()\n          })\n        })\n      }\n\n      function finish (err) {\n        if (err) {\n          return callback(err)\n        }\n\n        const half = resultLength / 2\n        const resultBuffer = Buffer.concat(result)\n        const r1 = resultBuffer.slice(0, half)\n        const r2 = resultBuffer.slice(half, resultLength)\n\n        const createKey = (res) => ({\n          iv: res.slice(0, ivSize),\n          cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n          macKey: res.slice(ivSize + cipherKeySize)\n        })\n\n        callback(null, {\n          k1: createKey(r1),\n          k2: createKey(r2)\n        })\n      }\n    })\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}