{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict';\n\nconst mh = require('multihashes');\nconst cryptoKeys = require('libp2p-crypto/src/keys');\nconst assert = require('assert');\nconst waterfall = require('async/waterfall');\nconst withIs = require('class-is');\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided');\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');\n    }\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n  get id() {\n    return this._id;\n  }\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n  get privKey() {\n    return this._privKey;\n  }\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n    const decoded = mh.decode(this.id);\n    if (decoded.name === 'identity') {\n      this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n      return this._pubKey;\n    }\n  }\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey() {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey);\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey() {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey);\n    }\n  }\n  toPrint() {\n    let pid = this.toB58String();\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2);\n    }\n    let maxRunes = 6;\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length;\n    }\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  }\n\n  // encode/decode functions\n  toHexString() {\n    return mh.toHexString(this.id);\n  }\n  toBytes() {\n    return this.id;\n  }\n  toB58String() {\n    return this._idB58String;\n  }\n  isEqual(id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id);\n    } else if (id.id) {\n      return this.id.equals(id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid(callback) {\n    // TODO Needs better checking\n    if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback();\n    } else {\n      callback(new Error('Keys not match'));\n    }\n  }\n}\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\nconst computeDigest = (pubKey, cb) => {\n  if (pubKey.bytes.length <= 42) {\n    const digest = mh.encode(pubKey.bytes, 'identity');\n    cb(null, digest);\n  } else {\n    pubKey.hash((err, digest) => {\n      cb(err, digest);\n    });\n  }\n};\nconst computePeerId = (privKey, pubKey, cb) => {\n  computeDigest(pubKey, (err, digest) => {\n    if (err != null) {\n      cb(err);\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey));\n    }\n  });\n};\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  opts.keyType = opts.keyType || 'RSA';\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str));\n};\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf);\n};\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str));\n};\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n  let pubKey;\n  try {\n    let buf = key;\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n    pubKey = cryptoKeys.unmarshalPublicKey(buf);\n  } catch (err) {\n    return callback(err);\n  }\n  computePeerId(null, pubKey, callback);\n};\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n  let buf = key;\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n  } catch (err) {\n    return callback(err);\n  }\n  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n  let id;\n  let rawPrivKey;\n  let rawPubKey;\n  let pub;\n  try {\n    id = mh.fromB58String(obj.id);\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey);\n  } catch (err) {\n    return callback(err);\n  }\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub));\n    return;\n  }\n  waterfall([cb => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb), (priv, cb) => {\n    computeDigest(priv.public, (err, digest) => {\n      cb(err, digest, priv);\n    });\n  }, (privDigest, priv, cb) => {\n    if (pub) {\n      computeDigest(pub, (err, pubDigest) => {\n        cb(err, privDigest, priv, pubDigest);\n      });\n    } else {\n      cb(null, privDigest, priv);\n    }\n  }], (err, privDigest, priv, pubDigest) => {\n    if (err) {\n      return callback(err);\n    }\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'));\n    }\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'));\n    }\n    callback(null, new PeerIdWithIs(id, priv, pub));\n  });\n};\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"names":["mh","require","cryptoKeys","assert","waterfall","withIs","PeerId","constructor","id","privKey","pubKey","Buffer","isBuffer","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","val","Error","decoded","decode","name","unmarshalPublicKey","digest","marshalPubKey","marshalPublicKey","marshalPrivKey","marshalPrivateKey","toPrint","pid","startsWith","slice","maxRunes","length","substr","toJSON","toB64Opt","toHexString","toBytes","isEqual","isValid","callback","PeerIdWithIs","className","symbolName","exports","module","computeDigest","cb","encode","hash","err","computePeerId","create","opts","bits","keyType","generateKeyPair","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","fromB58String","createFromPubKey","key","from","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","priv","privDigest","pubDigest","isPeerId","peerId","Boolean","toString"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/peer-id/src/index.js"],"sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst mh = require('multihashes')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst assert = require('assert')\nconst waterfall = require('async/waterfall')\nconst withIs = require('class-is')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided')\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n\n    const decoded = mh.decode(this.id)\n\n    if (decoded.name === 'identity') {\n      this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest)\n      return this._pubKey\n    }\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  isEqual (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid (callback) {\n    // TODO Needs better checking\n    if (this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback()\n    } else {\n      callback(new Error('Keys not match'))\n    }\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, { className: 'PeerId', symbolName: '@libp2p/js-peer-id/PeerId' })\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey, cb) => {\n  if (pubKey.bytes.length <= 42) {\n    const digest = mh.encode(pubKey.bytes, 'identity')\n    cb(null, digest)\n  } else {\n    pubKey.hash((err, digest) => {\n      cb(err, digest)\n    })\n  }\n}\n\nconst computePeerId = (privKey, pubKey, cb) => {\n  computeDigest(pubKey, (err, digest) => {\n    if (err != null) {\n      cb(err)\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey))\n    }\n  })\n}\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  }\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {\n    if (err != null) {\n      callback(err)\n    } else {\n      computePeerId(privKey, privKey.public, callback)\n    }\n  })\n}\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str))\n}\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf)\n}\n\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str))\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let pubKey\n\n  try {\n    let buf = key\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n\n    pubKey = cryptoKeys.unmarshalPublicKey(buf)\n  } catch (err) {\n    return callback(err)\n  }\n\n  computePeerId(null, pubKey, callback)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let buf = key\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n  } catch (err) {\n    return callback(err)\n  }\n\n  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {\n    if (err != null) {\n      callback(err)\n    } else {\n      computePeerId(privKey, privKey.public, callback)\n    }\n  })\n}\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let id\n  let rawPrivKey\n  let rawPubKey\n  let pub\n\n  try {\n    id = mh.fromB58String(obj.id)\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey)\n  } catch (err) {\n    return callback(err)\n  }\n\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub))\n    return\n  }\n\n  waterfall([\n    (cb) => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb),\n    (priv, cb) => {\n      computeDigest(priv.public, (err, digest) => {\n        cb(err, digest, priv)\n      })\n    },\n    (privDigest, priv, cb) => {\n      if (pub) {\n        computeDigest(pub, (err, pubDigest) => {\n          cb(err, privDigest, priv, pubDigest)\n        })\n      } else {\n        cb(null, privDigest, priv)\n      }\n    }\n  ], (err, privDigest, priv, pubDigest) => {\n    if (err) {\n      return callback(err)\n    }\n\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'))\n    }\n\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'))\n    }\n\n    callback(null, new PeerIdWithIs(id, priv, pub))\n  })\n}\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}