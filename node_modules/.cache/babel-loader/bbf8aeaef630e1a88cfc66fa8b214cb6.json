{"ast":null,"code":"/* eslint max-depth: 1 */\n'use strict';\n\nvar varint = require('varint');\nvar defined = require('./utils').defined;\nfunction toSentenceCase(string) {\n  return `${string.substring(0, 1).toUpperCase()}${string.substring(1)}`;\n}\nfunction addPropertyAccessors(obj, name, value, defaultValue) {\n  if (Object.prototype.hasOwnProperty.call(obj, name)) {\n    // have already added this property\n    return;\n  }\n  const sentenceCaseName = toSentenceCase(name);\n  Object.defineProperties(obj, {\n    [name]: {\n      enumerable: true,\n      configurable: true,\n      set: val => {\n        value = val;\n      },\n      get: () => {\n        if (value === undefined) {\n          return defaultValue;\n        }\n        return value;\n      }\n    },\n    [`has${sentenceCaseName}`]: {\n      configurable: true,\n      value: () => {\n        return value !== undefined;\n      }\n    },\n    [`set${sentenceCaseName}`]: {\n      configurable: true,\n      value: val => {\n        value = val;\n      }\n    },\n    [`get${sentenceCaseName}`]: {\n      configurable: true,\n      value: () => {\n        return value;\n      }\n    },\n    [`clear${sentenceCaseName}`]: {\n      configurable: true,\n      value: () => {\n        value = undefined;\n        obj[name] = undefined;\n      }\n    }\n  });\n}\nfunction compileDecode(m, resolve, enc) {\n  var requiredFields = [];\n  var fields = {};\n  var oneofFields = [];\n  var vals = [];\n  for (var i = 0; i < enc.length; i++) {\n    var field = m.fields[i];\n    fields[field.tag] = i;\n    var def = field.options && field.options.default;\n    var resolved = resolve(field.type, m.id, false);\n    vals[i] = [def, resolved && resolved.values];\n    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false';\n    if (field.required) {\n      requiredFields.push(field.name);\n    }\n    if (field.oneof) {\n      oneofFields.push(field.name);\n    }\n  }\n  function decodeField(e, field, obj, buf, offset, i) {\n    var name = field.name;\n    if (field.oneof) {\n      // clear already defined oneof fields\n      var props = Object.keys(obj);\n      for (var j = 0; j < props.length; j++) {\n        if (oneofFields.indexOf(props[j]) > -1) {\n          const sentenceCase = toSentenceCase(props[j]);\n          delete obj[`has${sentenceCase}`];\n          delete obj[`get${sentenceCase}`];\n          delete obj[`set${sentenceCase}`];\n          delete obj[`clear${sentenceCase}`];\n          delete obj[props[j]];\n        }\n      }\n    }\n    let value;\n    if (e.message) {\n      var len = varint.decode(buf, offset);\n      offset += varint.decode.bytes;\n      var decoded = e.decode(buf, offset, offset + len);\n      if (field.map) {\n        value = obj[name] || {};\n        value[decoded.key] = decoded.value;\n      } else if (field.repeated) {\n        value = obj[name] || [];\n        value.push(decoded);\n      } else {\n        value = decoded;\n      }\n    } else {\n      if (field.repeated) {\n        value = obj[name] || [];\n        value.push(e.decode(buf, offset));\n      } else {\n        value = e.decode(buf, offset);\n      }\n    }\n    addPropertyAccessors(obj, name, value);\n    offset += e.decode.bytes;\n    return offset;\n  }\n  return function decode(buf, offset, end) {\n    if (offset == null) {\n      offset = 0;\n    }\n    if (end == null) {\n      end = buf.length;\n    }\n    if (!(end <= buf.length && offset <= buf.length)) {\n      throw new Error('Decoded message is not valid');\n    }\n    var oldOffset = offset;\n    var obj = {};\n    var field;\n    while (true) {\n      if (end <= offset) {\n        // finished\n\n        // check required methods\n        var name = '';\n        var j = 0;\n        for (j = 0; j < requiredFields.length; j++) {\n          name = requiredFields[j];\n          if (!defined(obj[name])) {\n            throw new Error('Decoded message is not valid, missing required field: ' + name);\n          }\n        }\n\n        // fill out missing defaults\n        var val;\n        var def;\n        for (j = 0; j < enc.length; j++) {\n          field = m.fields[j];\n          def = vals[j][0];\n          val = vals[j][1];\n          name = field.name;\n          let defaultVal;\n          if (Object.prototype.hasOwnProperty.call(obj, name)) {\n            continue;\n          }\n          var done = false;\n          if (field.oneof) {\n            var props = Object.keys(obj);\n            for (var k = 0; k < props.length; k++) {\n              if (oneofFields.indexOf(props[k]) > -1) {\n                done = true;\n                break;\n              }\n            }\n          }\n          if (done) {\n            continue;\n          }\n          if (val) {\n            // is enum\n            if (field.repeated) {\n              def = [];\n            } else {\n              def = def && val[def] ? val[def].value : val[Object.keys(val)[0]].value;\n              def = parseInt(def || 0, 10);\n            }\n          } else {\n            defaultVal = defaultValue(field);\n            def = coerceValue(field, def);\n          }\n          addPropertyAccessors(obj, name, def, defaultVal);\n        }\n        decode.bytes = offset - oldOffset;\n        return obj;\n      }\n      var prefix = varint.decode(buf, offset);\n      offset += varint.decode.bytes;\n      var tag = prefix >> 3;\n      var i = fields[tag];\n      if (i == null) {\n        offset = skip(prefix & 7, buf, offset);\n        continue;\n      }\n      var e = enc[i];\n      field = m.fields[i];\n      if (field.packed) {\n        var packedEnd = varint.decode(buf, offset);\n        offset += varint.decode.bytes;\n        packedEnd += offset;\n        while (offset < packedEnd) {\n          offset = decodeField(e, field, obj, buf, offset, i);\n        }\n      } else {\n        offset = decodeField(e, field, obj, buf, offset, i);\n      }\n    }\n  };\n}\nvar skip = function (type, buffer, offset) {\n  switch (type) {\n    case 0:\n      varint.decode(buffer, offset);\n      return offset + varint.decode.bytes;\n    case 1:\n      return offset + 8;\n    case 2:\n      var len = varint.decode(buffer, offset);\n      return offset + varint.decode.bytes + len;\n    case 3:\n    case 4:\n      throw new Error('Groups are not supported');\n    case 5:\n      return offset + 4;\n    default:\n      throw new Error('Unknown wire type: ' + type);\n  }\n};\nvar defaultValue = function (f) {\n  if (f.map) return {};\n  if (f.repeated) return [];\n  switch (f.type) {\n    case 'string':\n      return '';\n    case 'bool':\n      return false;\n    case 'float':\n    case 'double':\n    case 'sfixed32':\n    case 'fixed32':\n    case 'varint':\n    case 'enum':\n    case 'uint64':\n    case 'uint32':\n    case 'int64':\n    case 'int32':\n    case 'sint64':\n    case 'sint32':\n      return 0;\n    default:\n      return null;\n  }\n};\nvar coerceValue = function (f, def) {\n  if (def === undefined) {\n    return def;\n  }\n  switch (f.type) {\n    case 'bool':\n      return def === 'true';\n    case 'float':\n    case 'double':\n    case 'sfixed32':\n    case 'fixed32':\n    case 'varint':\n    case 'enum':\n    case 'uint64':\n    case 'uint32':\n    case 'int64':\n    case 'int32':\n    case 'sint64':\n    case 'sint32':\n      return parseInt(def, 10);\n    default:\n      return def;\n  }\n};\nmodule.exports = compileDecode;","map":{"version":3,"names":["varint","require","defined","toSentenceCase","string","substring","toUpperCase","addPropertyAccessors","obj","name","value","defaultValue","Object","prototype","hasOwnProperty","call","sentenceCaseName","defineProperties","enumerable","configurable","set","val","get","undefined","compileDecode","m","resolve","enc","requiredFields","fields","oneofFields","vals","i","length","field","tag","def","options","default","resolved","type","id","values","packed","repeated","required","push","oneof","decodeField","e","buf","offset","props","keys","j","indexOf","sentenceCase","message","len","decode","bytes","decoded","map","key","end","Error","oldOffset","defaultVal","done","k","parseInt","coerceValue","prefix","skip","packedEnd","buffer","f","module","exports"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/protons/src/compile/decode.js"],"sourcesContent":["/* eslint max-depth: 1 */\n'use strict'\n\nvar varint = require('varint')\nvar defined = require('./utils').defined\n\nfunction toSentenceCase (string) {\n  return `${string.substring(0, 1).toUpperCase()}${string.substring(1)}`\n}\n\nfunction addPropertyAccessors (obj, name, value, defaultValue) {\n  if (Object.prototype.hasOwnProperty.call(obj, name)) {\n    // have already added this property\n    return\n  }\n\n  const sentenceCaseName = toSentenceCase(name)\n\n  Object.defineProperties(obj, {\n    [name]: {\n      enumerable: true,\n      configurable: true,\n      set: (val) => {\n        value = val\n      },\n      get: () => {\n        if (value === undefined) {\n          return defaultValue\n        }\n\n        return value\n      }\n    },\n    [`has${sentenceCaseName}`]: {\n      configurable: true,\n      value: () => {\n        return value !== undefined\n      }\n    },\n    [`set${sentenceCaseName}`]: {\n      configurable: true,\n      value: (val) => {\n        value = val\n      }\n    },\n    [`get${sentenceCaseName}`]: {\n      configurable: true,\n      value: () => {\n        return value\n      }\n    },\n    [`clear${sentenceCaseName}`]: {\n      configurable: true,\n      value: () => {\n        value = undefined\n        obj[name] = undefined\n      }\n    }\n  })\n}\n\nfunction compileDecode (m, resolve, enc) {\n  var requiredFields = []\n  var fields = {}\n  var oneofFields = []\n  var vals = []\n\n  for (var i = 0; i < enc.length; i++) {\n    var field = m.fields[i]\n\n    fields[field.tag] = i\n\n    var def = field.options && field.options.default\n    var resolved = resolve(field.type, m.id, false)\n    vals[i] = [def, resolved && resolved.values]\n\n    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false'\n\n    if (field.required) {\n      requiredFields.push(field.name)\n    }\n\n    if (field.oneof) {\n      oneofFields.push(field.name)\n    }\n  }\n\n  function decodeField (e, field, obj, buf, offset, i) {\n    var name = field.name\n\n    if (field.oneof) {\n      // clear already defined oneof fields\n      var props = Object.keys(obj)\n      for (var j = 0; j < props.length; j++) {\n        if (oneofFields.indexOf(props[j]) > -1) {\n          const sentenceCase = toSentenceCase(props[j])\n          delete obj[`has${sentenceCase}`]\n          delete obj[`get${sentenceCase}`]\n          delete obj[`set${sentenceCase}`]\n          delete obj[`clear${sentenceCase}`]\n          delete obj[props[j]]\n        }\n      }\n    }\n\n    let value\n\n    if (e.message) {\n      var len = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n\n      var decoded = e.decode(buf, offset, offset + len)\n\n      if (field.map) {\n        value = obj[name] || {}\n        value[decoded.key] = decoded.value\n      } else if (field.repeated) {\n        value = obj[name] || []\n        value.push(decoded)\n      } else {\n        value = decoded\n      }\n    } else {\n      if (field.repeated) {\n        value = obj[name] || []\n        value.push(e.decode(buf, offset))\n      } else {\n        value = e.decode(buf, offset)\n      }\n    }\n\n    addPropertyAccessors(obj, name, value)\n\n    offset += e.decode.bytes\n    return offset\n  }\n\n  return function decode (buf, offset, end) {\n    if (offset == null) {\n      offset = 0\n    }\n\n    if (end == null) {\n      end = buf.length\n    }\n\n    if (!(end <= buf.length && offset <= buf.length)) {\n      throw new Error('Decoded message is not valid')\n    }\n\n    var oldOffset = offset\n    var obj = {}\n    var field\n\n    while (true) {\n      if (end <= offset) {\n        // finished\n\n        // check required methods\n        var name = ''\n        var j = 0\n        for (j = 0; j < requiredFields.length; j++) {\n          name = requiredFields[j]\n          if (!defined(obj[name])) {\n            throw new Error('Decoded message is not valid, missing required field: ' + name)\n          }\n        }\n\n        // fill out missing defaults\n        var val\n        var def\n        for (j = 0; j < enc.length; j++) {\n          field = m.fields[j]\n          def = vals[j][0]\n          val = vals[j][1]\n          name = field.name\n          let defaultVal\n\n          if (Object.prototype.hasOwnProperty.call(obj, name)) {\n            continue\n          }\n\n          var done = false\n\n          if (field.oneof) {\n            var props = Object.keys(obj)\n\n            for (var k = 0; k < props.length; k++) {\n              if (oneofFields.indexOf(props[k]) > -1) {\n                done = true\n                break\n              }\n            }\n          }\n\n          if (done) {\n            continue\n          }\n\n          if (val) { // is enum\n            if (field.repeated) {\n              def = []\n            } else {\n              def = (def && val[def]) ? val[def].value : val[Object.keys(val)[0]].value\n              def = parseInt(def || 0, 10)\n            }\n          } else {\n            defaultVal = defaultValue(field)\n            def = coerceValue(field, def)\n          }\n\n          addPropertyAccessors(obj, name, def, defaultVal)\n        }\n\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n\n      var i = fields[tag]\n\n      if (i == null) {\n        offset = skip(prefix & 7, buf, offset)\n        continue\n      }\n\n      var e = enc[i]\n      field = m.fields[i]\n\n      if (field.packed) {\n        var packedEnd = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        packedEnd += offset\n\n        while (offset < packedEnd) {\n          offset = decodeField(e, field, obj, buf, offset, i)\n        }\n      } else {\n        offset = decodeField(e, field, obj, buf, offset, i)\n      }\n    }\n  }\n}\n\nvar skip = function (type, buffer, offset) {\n  switch (type) {\n    case 0:\n      varint.decode(buffer, offset)\n      return offset + varint.decode.bytes\n\n    case 1:\n      return offset + 8\n\n    case 2:\n      var len = varint.decode(buffer, offset)\n      return offset + varint.decode.bytes + len\n\n    case 3:\n    case 4:\n      throw new Error('Groups are not supported')\n\n    case 5:\n      return offset + 4\n    default:\n      throw new Error('Unknown wire type: ' + type)\n  }\n}\n\nvar defaultValue = function (f) {\n  if (f.map) return {}\n  if (f.repeated) return []\n\n  switch (f.type) {\n    case 'string':\n      return ''\n    case 'bool':\n      return false\n    case 'float':\n    case 'double':\n    case 'sfixed32':\n    case 'fixed32':\n    case 'varint':\n    case 'enum':\n    case 'uint64':\n    case 'uint32':\n    case 'int64':\n    case 'int32':\n    case 'sint64':\n    case 'sint32':\n      return 0\n    default:\n      return null\n  }\n}\n\nvar coerceValue = function (f, def) {\n  if (def === undefined) {\n    return def\n  }\n\n  switch (f.type) {\n    case 'bool':\n      return def === 'true'\n    case 'float':\n    case 'double':\n    case 'sfixed32':\n    case 'fixed32':\n    case 'varint':\n    case 'enum':\n    case 'uint64':\n    case 'uint32':\n    case 'int64':\n    case 'int32':\n    case 'sint64':\n    case 'sint32':\n      return parseInt(def, 10)\n    default:\n      return def\n  }\n}\n\nmodule.exports = compileDecode\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}