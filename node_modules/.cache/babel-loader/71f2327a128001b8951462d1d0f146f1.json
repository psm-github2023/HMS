{"ast":null,"code":"'use strict';\n\nconst codec = require('./codec');\nconst protocols = require('./protocols-table');\nconst varint = require('varint');\nconst bs58 = require('bs58');\nconst withIs = require('class-is');\n\n/**\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\n * a Buffer, String or another Multiaddr instance\n * public key.\n * @class Multiaddr\n * @param {(String|Buffer|Multiaddr)} addr - If String or Buffer, needs to adhere\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\nconst Multiaddr = withIs.proto(function (addr) {\n  if (!(this instanceof Multiaddr)) {\n    return new Multiaddr(addr);\n  }\n\n  // default\n  if (addr == null) {\n    addr = '';\n  }\n  if (addr instanceof Buffer) {\n    /**\n     * @type {Buffer} - The raw bytes representing this multiaddress\n     */\n    this.buffer = codec.fromBuffer(addr);\n  } else if (typeof addr === 'string' || addr instanceof String) {\n    if (addr.length > 0 && addr.charAt(0) !== '/') {\n      throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n    }\n    this.buffer = codec.fromString(addr);\n  } else if (addr.buffer && addr.protos && addr.protoCodes) {\n    // Multiaddr\n    this.buffer = codec.fromBuffer(addr.buffer); // validate + copy buffer\n  } else {\n    throw new Error('addr must be a string, Buffer, or another Multiaddr');\n  }\n}, {\n  className: 'Multiaddr',\n  symbolName: '@multiformats/js-multiaddr/multiaddr'\n});\n\n/**\n * Returns Multiaddr as a String\n *\n * @returns {String}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n * // '/ip4/127.0.0.1/tcp/4001'\n */\nMultiaddr.prototype.toString = function toString() {\n  return codec.bufferToString(this.buffer);\n};\n\n/**\n * Returns Multiaddr as a JSON encoded object\n *\n * @returns {String}\n * @example\n * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n * // '/ip4/127.0.0.1/tcp/4001'\n */\nMultiaddr.prototype.toJSON = Multiaddr.prototype.toString;\n\n/**\n * Returns Multiaddr as a convinient options object to be used with net.createConnection\n *\n * @returns {{family: String, host: String, transport: String, port: String}}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: '4001' }\n */\nMultiaddr.prototype.toOptions = function toOptions() {\n  const opts = {};\n  const parsed = this.toString().split('/');\n  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6';\n  opts.host = parsed[2];\n  opts.transport = parsed[3];\n  opts.port = parsed[4];\n  return opts;\n};\n\n/**\n * Returns Multiaddr as a human-readable string\n *\n * @returns {String}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n */\nMultiaddr.prototype.inspect = function inspect() {\n  return '<Multiaddr ' + this.buffer.toString('hex') + ' - ' + codec.bufferToString(this.buffer) + '>';\n};\n\n/**\n * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n * left-to-right order. Each object contains the protocol code, protocol name,\n * and the size of its address space in bits.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @returns {Array.<Object>} protocols - All the protocols the address is composed of\n * @returns {Number} protocols[].code\n * @returns {Number} protocols[].size\n * @returns {String} protocols[].name\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n * // [ { code: 4, size: 32, name: 'ip4' },\n * //   { code: 6, size: 16, name: 'tcp' } ]\n */\nMultiaddr.prototype.protos = function protos() {\n  return this.protoCodes().map(code => Object.assign({}, protocols(code)));\n};\n\n/**\n * Returns the codes of the protocols in left-to-right order.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @returns {Array.<Number>} protocol codes\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n * // [ 4, 6 ]\n */\nMultiaddr.prototype.protoCodes = function protoCodes() {\n  const codes = [];\n  const buf = this.buffer;\n  let i = 0;\n  while (i < buf.length) {\n    const code = varint.decode(buf, i);\n    const n = varint.decode.bytes;\n    const p = protocols(code);\n    const size = codec.sizeForAddr(p, buf.slice(i + n));\n    i += size + n;\n    codes.push(code);\n  }\n  return codes;\n};\n\n/**\n * Returns the names of the protocols in left-to-right order.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @return {Array.<String>} protocol names\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n * // [ 'ip4', 'tcp' ]\n */\nMultiaddr.prototype.protoNames = function protoNames() {\n  return this.protos().map(proto => proto.name);\n};\n\n/**\n * Returns a tuple of parts\n *\n * @return {Array.<Array>} tuples\n * @return {Number} tuples[].0 code of protocol\n * @return {Buffer} tuples[].1 contents of address\n * @example\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\n * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n */\nMultiaddr.prototype.tuples = function tuples() {\n  return codec.bufferToTuples(this.buffer);\n};\n\n/**\n * Returns a tuple of string/number parts\n *\n * @return {Array.<Array>} tuples\n * @return {Number} tuples[].0 code of protocol\n * @return {(String|Number)} tuples[].1 contents of address\n * @example\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\n * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\n */\nMultiaddr.prototype.stringTuples = function stringTuples() {\n  const t = codec.bufferToTuples(this.buffer);\n  return codec.tuplesToStringTuples(t);\n};\n\n/**\n * Encapsulates a Multiaddr in another Multiaddr\n *\n * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr\n * @return {Multiaddr}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n *\n * mh3.toString()\n * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n */\nMultiaddr.prototype.encapsulate = function encapsulate(addr) {\n  addr = Multiaddr(addr);\n  return Multiaddr(this.toString() + addr.toString());\n};\n\n/**\n * Decapsulates a Multiaddr from another Multiaddr\n *\n * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr\n * @return {Multiaddr}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n *\n * mh3.decapsulate(mh2).toString()\n * // '/ip4/8.8.8.8/tcp/1080'\n */\nMultiaddr.prototype.decapsulate = function decapsulate(addr) {\n  addr = addr.toString();\n  const s = this.toString();\n  const i = s.lastIndexOf(addr);\n  if (i < 0) {\n    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr);\n  }\n  return Multiaddr(s.slice(0, i));\n};\n\n/**\n * Extract the peerId if the multiaddr contains one\n *\n * @return {String|null} peerId - The id of the peer or null if invalid or missing from the ma\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\n *\n * // should return QmValidBase58string or null if the id is missing or invalid\n * const peerId = mh1.getPeerId()\n */\nMultiaddr.prototype.getPeerId = function getPeerId() {\n  let b58str = null;\n  try {\n    const tuples = this.stringTuples().filter(tuple => {\n      if (tuple[0] === protocols.names.ipfs.code) {\n        return true;\n      }\n    });\n\n    // Get the last id\n    b58str = tuples.pop()[1];\n    bs58.decode(b58str);\n  } catch (e) {\n    b58str = null;\n  }\n  return b58str;\n};\n\n/**\n * Extract the path if the multiaddr contains one\n *\n * @return {String|null} path - The path of the multiaddr, or null if no path protocol is present\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\n *\n * // should return utf8 string or null if the id is missing or invalid\n * const path = mh1.getPath()\n */\nMultiaddr.prototype.getPath = function getPath() {\n  let path = null;\n  try {\n    path = this.stringTuples().filter(tuple => {\n      const proto = protocols(tuple[0]);\n      if (proto.path) {\n        return true;\n      }\n    })[0][1];\n  } catch (e) {\n    path = null;\n  }\n  return path;\n};\n\n/**\n * Checks if two Multiaddrs are the same\n *\n * @param {Multiaddr} addr\n * @return {Bool}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * mh1.equals(mh1)\n * // true\n *\n * mh1.equals(mh2)\n * // false\n */\nMultiaddr.prototype.equals = function equals(addr) {\n  return this.buffer.equals(addr.buffer);\n};\n\n/**\n * Gets a Multiaddrs node-friendly address object. Note that protocol information\n * is left out: in Node (and most network systems) the protocol is unknowable\n * given only the address.\n *\n * Has to be a ThinWaist Address, otherwise throws error\n *\n * @returns {{family: String, address: String, port: String}}\n * @throws {Error} Throws error if Multiaddr is not a Thin Waist address\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\n */\nMultiaddr.prototype.nodeAddress = function nodeAddress() {\n  const codes = this.protoCodes();\n  const names = this.protoNames();\n  const parts = this.toString().split('/').slice(1);\n  if (parts.length < 4) {\n    throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".');\n  } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {\n    throw new Error(`no protocol with name: \"'${names[0]}'\". Must have a valid family name: \"{ip4, ip6, dns4, dns6}\".`);\n  } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {\n    throw new Error(`no protocol with name: \"'${names[1]}'\". Must have a valid transport protocol: \"{tcp, udp}\".`);\n  }\n  return {\n    family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,\n    address: parts[1],\n    // ip addr\n    port: parts[3] // tcp or udp port\n  };\n};\n\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @param {String} addr\n * @param {String} transport\n * @returns {Multiaddr} multiaddr\n * @throws {Error} Throws error if addr is not truthy\n * @throws {Error} Throws error if transport is not truthy\n * @example\n * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\nMultiaddr.fromNodeAddress = function fromNodeAddress(addr, transport) {\n  if (!addr) throw new Error('requires node address object');\n  if (!transport) throw new Error('requires transport protocol');\n  const ip = addr.family === 'IPv6' ? 'ip6' : 'ip4';\n  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'));\n};\n\n// TODO find a better example, not sure about it's good enough\n/**\n * Returns if a Multiaddr is a Thin Waist address or not.\n *\n * Thin Waist is if a Multiaddr adheres to the standard combination of:\n *\n * `{IPv4, IPv6}/{TCP, UDP}`\n *\n * @param {Multiaddr} [addr] - Defaults to using `this` instance\n * @returns {Boolean} isThinWaistAddress\n * @example\n * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\n * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\n * mh1.isThinWaistAddress()\n * // true\n * mh2.isThinWaistAddress()\n * // true\n * mh3.isThinWaistAddress()\n * // false\n */\nMultiaddr.prototype.isThinWaistAddress = function isThinWaistAddress(addr) {\n  const protos = (addr || this).protos();\n  if (protos.length !== 2) {\n    return false;\n  }\n  if (protos[0].code !== 4 && protos[0].code !== 41) {\n    return false;\n  }\n  if (protos[1].code !== 6 && protos[1].code !== 273) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Object containing table, names and codes of all supported protocols.\n * To get the protocol values from a Multiaddr, you can use\n * [`.protos()`](#multiaddrprotos),\n * [`.protoCodes()`](#multiaddrprotocodes) or\n * [`.protoNames()`](#multiaddrprotonames)\n *\n * @instance\n * @returns {{table: Array, names: Object, codes: Object}}\n *\n */\nMultiaddr.protocols = protocols;\n\n/**\n * Returns if something is a Multiaddr that is a name\n *\n * @param {Multiaddr} addr\n * @return {Bool} isName\n */\nMultiaddr.isName = function isName(addr) {\n  if (!Multiaddr.isMultiaddr(addr)) {\n    return false;\n  }\n\n  // if a part of the multiaddr is resolvable, then return true\n  return addr.protos().some(proto => proto.resolvable);\n};\n\n/**\n * Returns an array of multiaddrs, by resolving the multiaddr that is a name\n *\n * @param {Multiaddr} addr\n *\n * @param {Function} callback\n * @return {Bool} isName\n */\nMultiaddr.resolve = function resolve(addr, callback) {\n  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\n    return callback(new Error('not a valid name'));\n  }\n\n  /*\n   * Needs more consideration from spec design:\n   *   - what to return\n   *   - how to achieve it in the browser?\n   */\n  return callback(new Error('not implemented yet'));\n};\nexports = module.exports = Multiaddr;","map":{"version":3,"names":["codec","require","protocols","varint","bs58","withIs","Multiaddr","proto","addr","Buffer","buffer","fromBuffer","String","length","charAt","Error","fromString","protos","protoCodes","className","symbolName","prototype","toString","bufferToString","toJSON","toOptions","opts","parsed","split","family","host","transport","port","inspect","map","code","Object","assign","codes","buf","i","decode","n","bytes","p","size","sizeForAddr","slice","push","protoNames","name","tuples","bufferToTuples","stringTuples","t","tuplesToStringTuples","encapsulate","decapsulate","s","lastIndexOf","getPeerId","b58str","filter","tuple","names","ipfs","pop","e","getPath","path","equals","nodeAddress","parts","address","fromNodeAddress","ip","join","isThinWaistAddress","isName","isMultiaddr","some","resolvable","resolve","callback","exports","module"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/multiaddr/src/index.js"],"sourcesContent":["'use strict'\n\nconst codec = require('./codec')\nconst protocols = require('./protocols-table')\nconst varint = require('varint')\nconst bs58 = require('bs58')\nconst withIs = require('class-is')\n\n/**\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\n * a Buffer, String or another Multiaddr instance\n * public key.\n * @class Multiaddr\n * @param {(String|Buffer|Multiaddr)} addr - If String or Buffer, needs to adhere\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\nconst Multiaddr = withIs.proto(function (addr) {\n  if (!(this instanceof Multiaddr)) {\n    return new Multiaddr(addr)\n  }\n\n  // default\n  if (addr == null) {\n    addr = ''\n  }\n\n  if (addr instanceof Buffer) {\n    /**\n     * @type {Buffer} - The raw bytes representing this multiaddress\n     */\n    this.buffer = codec.fromBuffer(addr)\n  } else if (typeof addr === 'string' || addr instanceof String) {\n    if (addr.length > 0 && addr.charAt(0) !== '/') {\n      throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n    }\n    this.buffer = codec.fromString(addr)\n  } else if (addr.buffer && addr.protos && addr.protoCodes) { // Multiaddr\n    this.buffer = codec.fromBuffer(addr.buffer) // validate + copy buffer\n  } else {\n    throw new Error('addr must be a string, Buffer, or another Multiaddr')\n  }\n}, { className: 'Multiaddr', symbolName: '@multiformats/js-multiaddr/multiaddr' })\n\n/**\n * Returns Multiaddr as a String\n *\n * @returns {String}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n * // '/ip4/127.0.0.1/tcp/4001'\n */\nMultiaddr.prototype.toString = function toString () {\n  return codec.bufferToString(this.buffer)\n}\n\n/**\n * Returns Multiaddr as a JSON encoded object\n *\n * @returns {String}\n * @example\n * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n * // '/ip4/127.0.0.1/tcp/4001'\n */\nMultiaddr.prototype.toJSON = Multiaddr.prototype.toString\n\n/**\n * Returns Multiaddr as a convinient options object to be used with net.createConnection\n *\n * @returns {{family: String, host: String, transport: String, port: String}}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: '4001' }\n */\nMultiaddr.prototype.toOptions = function toOptions () {\n  const opts = {}\n  const parsed = this.toString().split('/')\n  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6'\n  opts.host = parsed[2]\n  opts.transport = parsed[3]\n  opts.port = parsed[4]\n  return opts\n}\n\n/**\n * Returns Multiaddr as a human-readable string\n *\n * @returns {String}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n */\nMultiaddr.prototype.inspect = function inspect () {\n  return '<Multiaddr ' +\n    this.buffer.toString('hex') + ' - ' +\n    codec.bufferToString(this.buffer) + '>'\n}\n\n/**\n * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n * left-to-right order. Each object contains the protocol code, protocol name,\n * and the size of its address space in bits.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @returns {Array.<Object>} protocols - All the protocols the address is composed of\n * @returns {Number} protocols[].code\n * @returns {Number} protocols[].size\n * @returns {String} protocols[].name\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n * // [ { code: 4, size: 32, name: 'ip4' },\n * //   { code: 6, size: 16, name: 'tcp' } ]\n */\nMultiaddr.prototype.protos = function protos () {\n  return this.protoCodes().map(code => Object.assign({}, protocols(code)))\n}\n\n/**\n * Returns the codes of the protocols in left-to-right order.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @returns {Array.<Number>} protocol codes\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n * // [ 4, 6 ]\n */\nMultiaddr.prototype.protoCodes = function protoCodes () {\n  const codes = []\n  const buf = this.buffer\n  let i = 0\n  while (i < buf.length) {\n    const code = varint.decode(buf, i)\n    const n = varint.decode.bytes\n\n    const p = protocols(code)\n    const size = codec.sizeForAddr(p, buf.slice(i + n))\n\n    i += (size + n)\n    codes.push(code)\n  }\n\n  return codes\n}\n\n/**\n * Returns the names of the protocols in left-to-right order.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @return {Array.<String>} protocol names\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n * // [ 'ip4', 'tcp' ]\n */\nMultiaddr.prototype.protoNames = function protoNames () {\n  return this.protos().map(proto => proto.name)\n}\n\n/**\n * Returns a tuple of parts\n *\n * @return {Array.<Array>} tuples\n * @return {Number} tuples[].0 code of protocol\n * @return {Buffer} tuples[].1 contents of address\n * @example\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\n * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n */\nMultiaddr.prototype.tuples = function tuples () {\n  return codec.bufferToTuples(this.buffer)\n}\n\n/**\n * Returns a tuple of string/number parts\n *\n * @return {Array.<Array>} tuples\n * @return {Number} tuples[].0 code of protocol\n * @return {(String|Number)} tuples[].1 contents of address\n * @example\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\n * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\n */\nMultiaddr.prototype.stringTuples = function stringTuples () {\n  const t = codec.bufferToTuples(this.buffer)\n  return codec.tuplesToStringTuples(t)\n}\n\n/**\n * Encapsulates a Multiaddr in another Multiaddr\n *\n * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr\n * @return {Multiaddr}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n *\n * mh3.toString()\n * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n */\nMultiaddr.prototype.encapsulate = function encapsulate (addr) {\n  addr = Multiaddr(addr)\n  return Multiaddr(this.toString() + addr.toString())\n}\n\n/**\n * Decapsulates a Multiaddr from another Multiaddr\n *\n * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr\n * @return {Multiaddr}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n *\n * mh3.decapsulate(mh2).toString()\n * // '/ip4/8.8.8.8/tcp/1080'\n */\nMultiaddr.prototype.decapsulate = function decapsulate (addr) {\n  addr = addr.toString()\n  const s = this.toString()\n  const i = s.lastIndexOf(addr)\n  if (i < 0) {\n    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr)\n  }\n  return Multiaddr(s.slice(0, i))\n}\n\n/**\n * Extract the peerId if the multiaddr contains one\n *\n * @return {String|null} peerId - The id of the peer or null if invalid or missing from the ma\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\n *\n * // should return QmValidBase58string or null if the id is missing or invalid\n * const peerId = mh1.getPeerId()\n */\nMultiaddr.prototype.getPeerId = function getPeerId () {\n  let b58str = null\n  try {\n    const tuples = this.stringTuples().filter((tuple) => {\n      if (tuple[0] === protocols.names.ipfs.code) {\n        return true\n      }\n    })\n\n    // Get the last id\n    b58str = tuples.pop()[1]\n\n    bs58.decode(b58str)\n  } catch (e) {\n    b58str = null\n  }\n\n  return b58str\n}\n\n/**\n * Extract the path if the multiaddr contains one\n *\n * @return {String|null} path - The path of the multiaddr, or null if no path protocol is present\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\n *\n * // should return utf8 string or null if the id is missing or invalid\n * const path = mh1.getPath()\n */\nMultiaddr.prototype.getPath = function getPath () {\n  let path = null\n  try {\n    path = this.stringTuples().filter((tuple) => {\n      const proto = protocols(tuple[0])\n      if (proto.path) {\n        return true\n      }\n    })[0][1]\n  } catch (e) {\n    path = null\n  }\n\n  return path\n}\n\n/**\n * Checks if two Multiaddrs are the same\n *\n * @param {Multiaddr} addr\n * @return {Bool}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * mh1.equals(mh1)\n * // true\n *\n * mh1.equals(mh2)\n * // false\n */\nMultiaddr.prototype.equals = function equals (addr) {\n  return this.buffer.equals(addr.buffer)\n}\n\n/**\n * Gets a Multiaddrs node-friendly address object. Note that protocol information\n * is left out: in Node (and most network systems) the protocol is unknowable\n * given only the address.\n *\n * Has to be a ThinWaist Address, otherwise throws error\n *\n * @returns {{family: String, address: String, port: String}}\n * @throws {Error} Throws error if Multiaddr is not a Thin Waist address\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\n */\nMultiaddr.prototype.nodeAddress = function nodeAddress () {\n  const codes = this.protoCodes()\n  const names = this.protoNames()\n  const parts = this.toString().split('/').slice(1)\n\n  if (parts.length < 4) {\n    throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".')\n  } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {\n    throw new Error(`no protocol with name: \"'${names[0]}'\". Must have a valid family name: \"{ip4, ip6, dns4, dns6}\".`)\n  } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {\n    throw new Error(`no protocol with name: \"'${names[1]}'\". Must have a valid transport protocol: \"{tcp, udp}\".`)\n  }\n\n  return {\n    family: (codes[0] === 41 || codes[0] === 55) ? 6 : 4,\n    address: parts[1], // ip addr\n    port: parts[3] // tcp or udp port\n  }\n}\n\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @param {String} addr\n * @param {String} transport\n * @returns {Multiaddr} multiaddr\n * @throws {Error} Throws error if addr is not truthy\n * @throws {Error} Throws error if transport is not truthy\n * @example\n * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\nMultiaddr.fromNodeAddress = function fromNodeAddress (addr, transport) {\n  if (!addr) throw new Error('requires node address object')\n  if (!transport) throw new Error('requires transport protocol')\n  const ip = (addr.family === 'IPv6') ? 'ip6' : 'ip4'\n  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'))\n}\n\n// TODO find a better example, not sure about it's good enough\n/**\n * Returns if a Multiaddr is a Thin Waist address or not.\n *\n * Thin Waist is if a Multiaddr adheres to the standard combination of:\n *\n * `{IPv4, IPv6}/{TCP, UDP}`\n *\n * @param {Multiaddr} [addr] - Defaults to using `this` instance\n * @returns {Boolean} isThinWaistAddress\n * @example\n * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\n * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\n * mh1.isThinWaistAddress()\n * // true\n * mh2.isThinWaistAddress()\n * // true\n * mh3.isThinWaistAddress()\n * // false\n */\nMultiaddr.prototype.isThinWaistAddress = function isThinWaistAddress (addr) {\n  const protos = (addr || this).protos()\n\n  if (protos.length !== 2) {\n    return false\n  }\n\n  if (protos[0].code !== 4 && protos[0].code !== 41) {\n    return false\n  }\n  if (protos[1].code !== 6 && protos[1].code !== 273) {\n    return false\n  }\n  return true\n}\n\n/**\n * Object containing table, names and codes of all supported protocols.\n * To get the protocol values from a Multiaddr, you can use\n * [`.protos()`](#multiaddrprotos),\n * [`.protoCodes()`](#multiaddrprotocodes) or\n * [`.protoNames()`](#multiaddrprotonames)\n *\n * @instance\n * @returns {{table: Array, names: Object, codes: Object}}\n *\n */\nMultiaddr.protocols = protocols\n\n/**\n * Returns if something is a Multiaddr that is a name\n *\n * @param {Multiaddr} addr\n * @return {Bool} isName\n */\nMultiaddr.isName = function isName (addr) {\n  if (!Multiaddr.isMultiaddr(addr)) {\n    return false\n  }\n\n  // if a part of the multiaddr is resolvable, then return true\n  return addr.protos().some((proto) => proto.resolvable)\n}\n\n/**\n * Returns an array of multiaddrs, by resolving the multiaddr that is a name\n *\n * @param {Multiaddr} addr\n *\n * @param {Function} callback\n * @return {Bool} isName\n */\nMultiaddr.resolve = function resolve (addr, callback) {\n  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\n    return callback(new Error('not a valid name'))\n  }\n\n  /*\n   * Needs more consideration from spec design:\n   *   - what to return\n   *   - how to achieve it in the browser?\n   */\n  return callback(new Error('not implemented yet'))\n}\n\nexports = module.exports = Multiaddr\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}