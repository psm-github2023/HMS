{"ast":null,"code":"'use strict';\n\nconst multihashing = require('multihashing-async');\nconst protobuf = require('protons');\nconst bs58 = require('bs58');\nconst crypto = require('./ed25519');\nconst pbm = protobuf(require('./keys.proto'));\nclass Ed25519PublicKey {\n  constructor(key) {\n    this._key = ensureKey(key, crypto.publicKeyLength);\n  }\n  verify(data, sig, callback) {\n    ensure(callback);\n    crypto.hashAndVerify(this._key, sig, data, callback);\n  }\n  marshal() {\n    return Buffer.from(this._key);\n  }\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    });\n  }\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n  hash(callback) {\n    ensure(callback);\n    multihashing(this.bytes, 'sha2-256', callback);\n  }\n}\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array or Buffer containing private key\n  // publicKey - 32 byte Uint8Array or Buffer containing public key\n  constructor(key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength);\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);\n  }\n  sign(message, callback) {\n    ensure(callback);\n    crypto.hashAndSign(this._key, message, callback);\n  }\n  get public() {\n    if (!this._publicKey) {\n      throw new Error('public key not provided');\n    }\n    return new Ed25519PublicKey(this._publicKey);\n  }\n  marshal() {\n    return Buffer.concat([Buffer.from(this._key), Buffer.from(this._publicKey)]);\n  }\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    });\n  }\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n  hash(callback) {\n    ensure(callback);\n    multihashing(this.bytes, 'sha2-256', callback);\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @param {function(Error, id)} callback\n   * @returns {undefined}\n   */\n  id(callback) {\n    this.public.hash((err, hash) => {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, bs58.encode(hash));\n    });\n  }\n}\nfunction unmarshalEd25519PrivateKey(bytes, callback) {\n  try {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n  } catch (err) {\n    return callback(err);\n  }\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n  const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length);\n  callback(null, new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes));\n}\nfunction unmarshalEd25519PublicKey(bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength);\n  return new Ed25519PublicKey(bytes);\n}\nfunction generateKeyPair(_bits, cb) {\n  if (cb === undefined && typeof _bits === 'function') {\n    cb = _bits;\n  }\n  crypto.generateKey((err, keys) => {\n    if (err) {\n      return cb(err);\n    }\n    let privkey;\n    try {\n      privkey = new Ed25519PrivateKey(keys.secretKey, keys.publicKey);\n    } catch (err) {\n      cb(err);\n      return;\n    }\n    cb(null, privkey);\n  });\n}\nfunction generateKeyPairFromSeed(seed, _bits, cb) {\n  if (cb === undefined && typeof _bits === 'function') {\n    cb = _bits;\n  }\n  crypto.generateKeyFromSeed(seed, (err, keys) => {\n    if (err) {\n      return cb(err);\n    }\n    let privkey;\n    try {\n      privkey = new Ed25519PrivateKey(keys.secretKey, keys.publicKey);\n    } catch (err) {\n      cb(err);\n      return;\n    }\n    cb(null, privkey);\n  });\n}\nfunction ensure(cb) {\n  if (typeof cb !== 'function') {\n    throw new Error('callback is required');\n  }\n}\nfunction ensureKey(key, length) {\n  if (Buffer.isBuffer(key)) {\n    key = new Uint8Array(key);\n  }\n  if (!(key instanceof Uint8Array) || key.length !== length) {\n    throw new Error('Key must be a Uint8Array or Buffer of length ' + length);\n  }\n  return key;\n}\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n};","map":{"version":3,"names":["multihashing","require","protobuf","bs58","crypto","pbm","Ed25519PublicKey","constructor","key","_key","ensureKey","publicKeyLength","verify","data","sig","callback","ensure","hashAndVerify","marshal","Buffer","from","bytes","PublicKey","encode","Type","KeyType","Ed25519","Data","equals","hash","Ed25519PrivateKey","publicKey","privateKeyLength","_publicKey","sign","message","hashAndSign","public","Error","concat","PrivateKey","id","err","unmarshalEd25519PrivateKey","privateKeyBytes","slice","publicKeyBytes","length","unmarshalEd25519PublicKey","generateKeyPair","_bits","cb","undefined","generateKey","keys","privkey","secretKey","generateKeyPairFromSeed","seed","generateKeyFromSeed","isBuffer","Uint8Array","module","exports"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/libp2p-crypto/src/keys/ed25519-class.js"],"sourcesContent":["'use strict'\n\nconst multihashing = require('multihashing-async')\nconst protobuf = require('protons')\nconst bs58 = require('bs58')\n\nconst crypto = require('./ed25519')\nconst pbm = protobuf(require('./keys.proto'))\n\nclass Ed25519PublicKey {\n  constructor (key) {\n    this._key = ensureKey(key, crypto.publicKeyLength)\n  }\n\n  verify (data, sig, callback) {\n    ensure(callback)\n    crypto.hashAndVerify(this._key, sig, data, callback)\n  }\n\n  marshal () {\n    return Buffer.from(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  hash (callback) {\n    ensure(callback)\n    multihashing(this.bytes, 'sha2-256', callback)\n  }\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array or Buffer containing private key\n  // publicKey - 32 byte Uint8Array or Buffer containing public key\n  constructor (key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength)\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength)\n  }\n\n  sign (message, callback) {\n    ensure(callback)\n    crypto.hashAndSign(this._key, message, callback)\n  }\n\n  get public () {\n    if (!this._publicKey) {\n      throw new Error('public key not provided')\n    }\n\n    return new Ed25519PublicKey(this._publicKey)\n  }\n\n  marshal () {\n    return Buffer.concat([Buffer.from(this._key), Buffer.from(this._publicKey)])\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  hash (callback) {\n    ensure(callback)\n    multihashing(this.bytes, 'sha2-256', callback)\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @param {function(Error, id)} callback\n   * @returns {undefined}\n   */\n  id (callback) {\n    this.public.hash((err, hash) => {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, bs58.encode(hash))\n    })\n  }\n}\n\nfunction unmarshalEd25519PrivateKey (bytes, callback) {\n  try {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n  } catch (err) {\n    return callback(err)\n  }\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length)\n  callback(null, new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes))\n}\n\nfunction unmarshalEd25519PublicKey (bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKey(bytes)\n}\n\nfunction generateKeyPair (_bits, cb) {\n  if (cb === undefined && typeof _bits === 'function') {\n    cb = _bits\n  }\n\n  crypto.generateKey((err, keys) => {\n    if (err) {\n      return cb(err)\n    }\n    let privkey\n    try {\n      privkey = new Ed25519PrivateKey(keys.secretKey, keys.publicKey)\n    } catch (err) {\n      cb(err)\n      return\n    }\n\n    cb(null, privkey)\n  })\n}\n\nfunction generateKeyPairFromSeed (seed, _bits, cb) {\n  if (cb === undefined && typeof _bits === 'function') {\n    cb = _bits\n  }\n\n  crypto.generateKeyFromSeed(seed, (err, keys) => {\n    if (err) {\n      return cb(err)\n    }\n    let privkey\n    try {\n      privkey = new Ed25519PrivateKey(keys.secretKey, keys.publicKey)\n    } catch (err) {\n      cb(err)\n      return\n    }\n\n    cb(null, privkey)\n  })\n}\n\nfunction ensure (cb) {\n  if (typeof cb !== 'function') {\n    throw new Error('callback is required')\n  }\n}\n\nfunction ensureKey (key, length) {\n  if (Buffer.isBuffer(key)) {\n    key = new Uint8Array(key)\n  }\n  if (!(key instanceof Uint8Array) || key.length !== length) {\n    throw new Error('Key must be a Uint8Array or Buffer of length ' + length)\n  }\n  return key\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}