{"ast":null,"code":"'use strict';\n\nconst {\n  Duplex\n} = require('readable-stream');\nconst eachSeries = require('async/eachSeries');\nconst isStream = require('is-stream');\nconst once = require('once');\nconst prepareFile = require('./prepare-file');\nconst Multipart = require('./multipart');\nfunction headers(file, i) {\n  const filename = file.path ? encodeURIComponent(file.path) : '';\n  const header = {\n    'Content-Disposition': `form-data; name=\"data${i}\"; filename=\"${filename}\"`\n  };\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory';\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink';\n  } else {\n    header['Content-Type'] = 'application/octet-stream';\n  }\n  return header;\n}\nmodule.exports = (send, path) => {\n  return options => {\n    let request;\n    let ended = false;\n    let writing = false;\n    options = options ? Object.assign({}, options, options.qs) : {};\n    const multipart = new Multipart();\n    const retStream = new Duplex({\n      objectMode: true\n    });\n    retStream._read = n => {};\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next);\n      try {\n        const files = prepareFile(file, options).map((file, i) => Object.assign({\n          headers: headers(file, i)\n        }, file));\n        writing = true;\n        eachSeries(files, (file, cb) => multipart.write(file, enc, cb), err => {\n          writing = false;\n          if (err) {\n            return next(err);\n          }\n          if (ended) {\n            multipart.end();\n          }\n          next();\n        });\n      } catch (err) {\n        next(err);\n      }\n    };\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true;\n        if (!writing) {\n          multipart.end();\n        }\n      }\n    });\n    const qs = options.qs || {};\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion');\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves');\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash');\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory');\n    qs.hash = propOrProp(options, 'hash', 'hashAlg');\n    if (options.strategy === 'trickle' || options.trickle) {\n      qs['trickle'] = 'true';\n    }\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    };\n    multipart.on('error', err => {\n      retStream.emit('error', err);\n    });\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err);\n      }\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null); // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response);\n        retStream.push(null);\n        return;\n      }\n      response.on('error', err => retStream.emit('error', err));\n      if (options.converter) {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n        });\n        const Converter = options.converter;\n        const convertedResponse = new Converter();\n        convertedResponse.once('end', () => retStream.push(null));\n        convertedResponse.on('data', d => retStream.push(d));\n        response.pipe(convertedResponse);\n      } else {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n          retStream.push(d);\n        });\n        response.once('end', () => retStream.push(null));\n      }\n    });\n\n    // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n    request.on('drain', () => multipart.emit('drain'));\n    multipart.pipe(request);\n    return retStream;\n  };\n};\nfunction propOrProp(source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1];\n  } else if (prop2 in source) {\n    return source[prop2];\n  }\n}","map":{"version":3,"names":["Duplex","require","eachSeries","isStream","once","prepareFile","Multipart","headers","file","i","filename","path","encodeURIComponent","header","content","symlink","module","exports","send","options","request","ended","writing","Object","assign","qs","multipart","retStream","objectMode","_read","n","_write","enc","_next","next","files","map","cb","write","err","end","propOrProp","hash","strategy","trickle","args","multipartBoundary","_boundary","stream","recursive","progress","on","emit","response","push","converter","d","Bytes","Converter","convertedResponse","pipe","source","prop1","prop2"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/ipfs-http-client/src/utils/send-files-stream.js"],"sourcesContent":["'use strict'\n\nconst { Duplex } = require('readable-stream')\nconst eachSeries = require('async/eachSeries')\nconst isStream = require('is-stream')\nconst once = require('once')\nconst prepareFile = require('./prepare-file')\nconst Multipart = require('./multipart')\n\nfunction headers (file, i) {\n  const filename = file.path\n    ? encodeURIComponent(file.path)\n    : ''\n\n  const header = { 'Content-Disposition': `form-data; name=\"data${i}\"; filename=\"${filename}\"` }\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory'\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink'\n  } else {\n    header['Content-Type'] = 'application/octet-stream'\n  }\n\n  return header\n}\n\nmodule.exports = (send, path) => {\n  return (options) => {\n    let request\n    let ended = false\n    let writing = false\n\n    options = options ? Object.assign({}, options, options.qs) : {}\n\n    const multipart = new Multipart()\n\n    const retStream = new Duplex({ objectMode: true })\n\n    retStream._read = (n) => {}\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next)\n      try {\n        const files = prepareFile(file, options)\n          .map((file, i) => Object.assign({ headers: headers(file, i) }, file))\n\n        writing = true\n        eachSeries(\n          files,\n          (file, cb) => multipart.write(file, enc, cb),\n          (err) => {\n            writing = false\n            if (err) {\n              return next(err)\n            }\n            if (ended) {\n              multipart.end()\n            }\n            next()\n          })\n      } catch (err) {\n        next(err)\n      }\n    }\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true\n        if (!writing) {\n          multipart.end()\n        }\n      }\n    })\n\n    const qs = options.qs || {}\n\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion')\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves')\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash')\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory')\n    qs.hash = propOrProp(options, 'hash', 'hashAlg')\n\n    if (options.strategy === 'trickle' || options.trickle) {\n      qs['trickle'] = 'true'\n    }\n\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    }\n\n    multipart.on('error', (err) => {\n      retStream.emit('error', err)\n    })\n\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err)\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null) // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response)\n        retStream.push(null)\n        return\n      }\n\n      response.on('error', (err) => retStream.emit('error', err))\n\n      if (options.converter) {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n        })\n\n        const Converter = options.converter\n        const convertedResponse = new Converter()\n        convertedResponse.once('end', () => retStream.push(null))\n        convertedResponse.on('data', (d) => retStream.push(d))\n        response.pipe(convertedResponse)\n      } else {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n          retStream.push(d)\n        })\n        response.once('end', () => retStream.push(null))\n      }\n    })\n\n    // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n    request.on('drain', () => multipart.emit('drain'))\n\n    multipart.pipe(request)\n\n    return retStream\n  }\n}\n\nfunction propOrProp (source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1]\n  } else if (prop2 in source) {\n    return source[prop2]\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}