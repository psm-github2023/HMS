{"ast":null,"code":"'use strict';\n\nconst Qs = require('qs');\nconst qsDefaultEncoder = require('qs/lib/utils').encode;\nconst isNode = require('detect-node');\nconst ndjson = require('ndjson');\nconst pump = require('pump');\nconst once = require('once');\nconst {\n  getRequest\n} = require('iso-stream-http');\nconst streamToValue = require('./stream-to-value');\nconst streamToJsonValue = require('./stream-to-json-value');\nconst log = require('debug')('ipfs-http-client:request');\n\n// -- Internal\n\nfunction hasJSONHeaders(res) {\n  return res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') === 0;\n}\nfunction parseError(res, cb) {\n  const error = new Error(`Server responded with ${res.statusCode}`);\n  error.statusCode = res.statusCode;\n  if (!hasJSONHeaders(res)) {\n    return streamToValue(res, (err, data) => {\n      // eslint-disable-line handle-callback-err\n      // the `err` here refers to errors in stream processing, which\n      // we ignore here, since we already have a valid `error` response\n      // from the server above that we have to report to the caller.\n      if (data && data.length) {\n        error.message = data.toString();\n      }\n      cb(error);\n    });\n  }\n  streamToJsonValue(res, (err, payload) => {\n    if (err) {\n      return cb(err);\n    }\n    if (payload) {\n      error.code = payload.Code;\n      error.message = payload.Message || payload.toString();\n      error.type = payload.Type;\n    }\n    cb(error);\n  });\n}\nfunction onRes(buffer, cb) {\n  return res => {\n    const stream = Boolean(res.headers['x-stream-output']);\n    const chunkedObjects = Boolean(res.headers['x-chunked-output']);\n    const isJson = hasJSONHeaders(res);\n    if (res.req) {\n      log(res.req.method, `${res.req.getHeaders().host}${res.req.path}`, res.statusCode, res.statusMessage);\n    } else {\n      log(res.url, res.statusCode, res.statusMessage);\n    }\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb);\n    }\n\n    // Return the response stream directly\n    if (stream && !buffer) {\n      return cb(null, res);\n    }\n\n    // Return a stream of JSON objects\n    if (chunkedObjects && isJson) {\n      const outputStream = ndjson.parse();\n      pump(res, outputStream);\n      res.on('end', () => {\n        let err = res.trailers['x-stream-error'];\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err);\n          } catch (e) {\n            err = {\n              Message: err\n            };\n          }\n          outputStream.emit('error', new Error(err.Message));\n        }\n      });\n      return cb(null, outputStream);\n    }\n\n    // Return a JSON object\n    if (isJson) {\n      return streamToJsonValue(res, cb);\n    }\n\n    // Return a value\n    return streamToValue(res, cb);\n  };\n}\nfunction requestAPI(config, options, callback) {\n  callback = once(callback);\n  options.qs = options.qs || {};\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/');\n  }\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args];\n  }\n  if (options.args) {\n    options.qs.arg = options.args;\n  }\n  if (options.progress) {\n    options.qs.progress = true;\n  }\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r;\n    // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n    delete options.qs.r;\n  }\n  options.qs['stream-channels'] = true;\n  if (options.stream) {\n    options.buffer = false;\n  }\n\n  // this option is only used internally, not passed to daemon\n  delete options.qs.followSymlinks;\n  const method = 'POST';\n  const headers = Object.assign({}, config.headers);\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent'];\n  }\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'));\n    }\n    headers['Content-Type'] = `multipart/form-data; boundary=${options.multipartBoundary}`;\n  }\n  const qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: data => {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        let uriEncoded = '';\n        for (const byte of data) {\n          // https://tools.ietf.org/html/rfc3986#page-14\n          // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n          if (byte >= 0x41 && byte <= 0x5A || byte >= 0x61 && byte <= 0x7A || byte >= 0x30 && byte <= 0x39 || byte === 0x2D || byte === 0x2E || byte === 0x5F || byte === 0x7E) {\n            uriEncoded += String.fromCharCode(byte);\n          } else {\n            const hex = byte.toString(16);\n            // String.prototype.padStart() not widely supported yet\n            const padded = hex.length === 1 ? `0${hex}` : hex;\n            uriEncoded += `%${padded}`;\n          }\n        }\n        return uriEncoded;\n      }\n      return qsDefaultEncoder(data);\n    }\n  });\n  const reqOptions = {\n    hostname: config.host,\n    path: `${config['api-path']}${options.path}?${qs}`,\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: `${config.protocol}:`\n  };\n  const req = getRequest(reqOptions, onRes(options.buffer, callback));\n  req.on('error', err => {\n    callback(err);\n  });\n  if (!options.stream) {\n    req.end();\n  }\n  return req;\n}\n\n//\n// -- Module Interface\n\nexports = module.exports = config => {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  const send = (options, callback) => {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'));\n    }\n    return requestAPI(config, options, callback);\n  };\n\n  // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n  send.andTransform = (options, transform, callback) => {\n    return send(options, (err, res) => {\n      if (err) {\n        return callback(err);\n      }\n      transform(res, callback);\n    });\n  };\n  return send;\n};","map":{"version":3,"names":["Qs","require","qsDefaultEncoder","encode","isNode","ndjson","pump","once","getRequest","streamToValue","streamToJsonValue","log","hasJSONHeaders","res","headers","indexOf","parseError","cb","error","Error","statusCode","err","data","length","message","toString","payload","code","Code","Message","type","Type","onRes","buffer","stream","Boolean","chunkedObjects","isJson","req","method","getHeaders","host","path","statusMessage","url","outputStream","parse","on","trailers","JSON","e","emit","requestAPI","config","options","callback","qs","Array","isArray","join","args","arg","progress","r","recursive","followSymlinks","Object","assign","multipart","multipartBoundary","stringify","arrayFormat","encoder","Buffer","isBuffer","uriEncoded","byte","String","fromCharCode","hex","padded","reqOptions","hostname","port","protocol","end","exports","module","send","andTransform","transform"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/ipfs-http-client/src/utils/send-request.js"],"sourcesContent":["'use strict'\n\nconst Qs = require('qs')\nconst qsDefaultEncoder = require('qs/lib/utils').encode\nconst isNode = require('detect-node')\nconst ndjson = require('ndjson')\nconst pump = require('pump')\nconst once = require('once')\nconst { getRequest } = require('iso-stream-http')\nconst streamToValue = require('./stream-to-value')\nconst streamToJsonValue = require('./stream-to-json-value')\nconst log = require('debug')('ipfs-http-client:request')\n\n// -- Internal\n\nfunction hasJSONHeaders (res) {\n  return res.headers['content-type'] &&\n    res.headers['content-type'].indexOf('application/json') === 0\n}\n\nfunction parseError (res, cb) {\n  const error = new Error(`Server responded with ${res.statusCode}`)\n  error.statusCode = res.statusCode\n\n  if (!hasJSONHeaders(res)) {\n    return streamToValue(res, (err, data) => { // eslint-disable-line handle-callback-err\n      // the `err` here refers to errors in stream processing, which\n      // we ignore here, since we already have a valid `error` response\n      // from the server above that we have to report to the caller.\n      if (data && data.length) {\n        error.message = data.toString()\n      }\n      cb(error)\n    })\n  }\n\n  streamToJsonValue(res, (err, payload) => {\n    if (err) {\n      return cb(err)\n    }\n\n    if (payload) {\n      error.code = payload.Code\n      error.message = payload.Message || payload.toString()\n      error.type = payload.Type\n    }\n    cb(error)\n  })\n}\n\nfunction onRes (buffer, cb) {\n  return (res) => {\n    const stream = Boolean(res.headers['x-stream-output'])\n    const chunkedObjects = Boolean(res.headers['x-chunked-output'])\n    const isJson = hasJSONHeaders(res)\n\n    if (res.req) {\n      log(res.req.method, `${res.req.getHeaders().host}${res.req.path}`, res.statusCode, res.statusMessage)\n    } else {\n      log(res.url, res.statusCode, res.statusMessage)\n    }\n\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb)\n    }\n\n    // Return the response stream directly\n    if (stream && !buffer) {\n      return cb(null, res)\n    }\n\n    // Return a stream of JSON objects\n    if (chunkedObjects && isJson) {\n      const outputStream = ndjson.parse()\n      pump(res, outputStream)\n      res.on('end', () => {\n        let err = res.trailers['x-stream-error']\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err)\n          } catch (e) {\n            err = { Message: err }\n          }\n          outputStream.emit('error', new Error(err.Message))\n        }\n      })\n      return cb(null, outputStream)\n    }\n\n    // Return a JSON object\n    if (isJson) {\n      return streamToJsonValue(res, cb)\n    }\n\n    // Return a value\n    return streamToValue(res, cb)\n  }\n}\n\nfunction requestAPI (config, options, callback) {\n  callback = once(callback)\n  options.qs = options.qs || {}\n\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/')\n  }\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args]\n  }\n  if (options.args) {\n    options.qs.arg = options.args\n  }\n  if (options.progress) {\n    options.qs.progress = true\n  }\n\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r\n    // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n    delete options.qs.r\n  }\n\n  options.qs['stream-channels'] = true\n\n  if (options.stream) {\n    options.buffer = false\n  }\n\n  // this option is only used internally, not passed to daemon\n  delete options.qs.followSymlinks\n\n  const method = 'POST'\n  const headers = Object.assign({}, config.headers)\n\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent']\n  }\n\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'))\n    }\n\n    headers['Content-Type'] = `multipart/form-data; boundary=${options.multipartBoundary}`\n  }\n\n  const qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: data => {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        let uriEncoded = ''\n        for (const byte of data) {\n          // https://tools.ietf.org/html/rfc3986#page-14\n          // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n          if (\n            (byte >= 0x41 && byte <= 0x5A) ||\n            (byte >= 0x61 && byte <= 0x7A) ||\n            (byte >= 0x30 && byte <= 0x39) ||\n            (byte === 0x2D) ||\n            (byte === 0x2E) ||\n            (byte === 0x5F) ||\n            (byte === 0x7E)\n          ) {\n            uriEncoded += String.fromCharCode(byte)\n          } else {\n            const hex = byte.toString(16)\n            // String.prototype.padStart() not widely supported yet\n            const padded = hex.length === 1 ? `0${hex}` : hex\n            uriEncoded += `%${padded}`\n          }\n        }\n        return uriEncoded\n      }\n      return qsDefaultEncoder(data)\n    }\n  })\n  const reqOptions = {\n    hostname: config.host,\n    path: `${config['api-path']}${options.path}?${qs}`,\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: `${config.protocol}:`\n  }\n\n  const req = getRequest(reqOptions, onRes(options.buffer, callback))\n\n  req.on('error', (err) => {\n    callback(err)\n  })\n\n  if (!options.stream) {\n    req.end()\n  }\n\n  return req\n}\n\n//\n// -- Module Interface\n\nexports = module.exports = (config) => {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  const send = (options, callback) => {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'))\n    }\n\n    return requestAPI(config, options, callback)\n  }\n\n  // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n  send.andTransform = (options, transform, callback) => {\n    return send(options, (err, res) => {\n      if (err) {\n        return callback(err)\n      }\n      transform(res, callback)\n    })\n  }\n\n  return send\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}