{"ast":null,"code":"var capability = require('./capability');\nvar inherits = require('inherits');\nvar stream = require('readable-stream');\nvar IncomingMessage = function (response, mode, fetchTimer) {\n  stream.Readable.call(this);\n  this._mode = mode;\n  this.headers = {};\n  this.rawHeaders = [];\n  this.trailers = {};\n  this.rawTrailers = [];\n\n  // Fake the 'close' event, but only once 'end' fires\n  this.on('end', () => {\n    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n    process.nextTick(() => this.emit('close'));\n  });\n  this._fetchResponse = response;\n  this.url = response.url;\n  this.statusCode = response.status;\n  this.statusMessage = response.statusText;\n  response.headers.forEach((header, key) => {\n    this.headers[key.toLowerCase()] = header;\n    this.rawHeaders.push(key, header);\n  });\n  if (capability.writableStream) {\n    var writable = new WritableStream({\n      write: chunk => {\n        return new Promise((resolve, reject) => {\n          if (this._destroyed) {\n            reject();\n          } else if (this.push(Buffer.from(chunk))) {\n            resolve();\n          } else {\n            this._resumeFetch = resolve;\n          }\n        });\n      },\n      close: () => {\n        clearTimeout(fetchTimer);\n        if (!this._destroyed) {\n          this.push(null);\n        }\n      },\n      abort: err => {\n        if (!this._destroyed) {\n          this.emit('error', err);\n        }\n      }\n    });\n    try {\n      response.body.pipeTo(writable).catch(err => {\n        console.log(err);\n        self.clearTimeout(fetchTimer);\n        if (!this._destroyed) {\n          this.emit('error', err);\n        }\n      });\n      return;\n    } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n  }\n  // fallback for when writableStream or pipeTo aren't available\n  var reader = response.body.getReader();\n  function read(context) {\n    reader.read().then(result => {\n      if (context._destroyed) {\n        return;\n      }\n      if (result.done) {\n        clearTimeout(fetchTimer);\n        context.push(null);\n        return;\n      }\n      context.push(Buffer.from(result.value));\n      read(context);\n    }).catch(err => {\n      clearTimeout(fetchTimer);\n      if (!context._destroyed) {\n        context.emit('error', err);\n      }\n    });\n  }\n  read(this);\n};\ninherits(IncomingMessage, stream.Readable);\nIncomingMessage.prototype._read = function () {\n  var resolve = this._resumeFetch;\n  if (resolve) {\n    this._resumeFetch = null;\n    resolve();\n  }\n};\nmodule.exports = IncomingMessage;","map":{"version":3,"names":["capability","require","inherits","stream","IncomingMessage","response","mode","fetchTimer","Readable","call","_mode","headers","rawHeaders","trailers","rawTrailers","on","process","nextTick","emit","_fetchResponse","url","statusCode","status","statusMessage","statusText","forEach","header","key","toLowerCase","push","writableStream","writable","WritableStream","write","chunk","Promise","resolve","reject","_destroyed","Buffer","from","_resumeFetch","close","clearTimeout","abort","err","body","pipeTo","catch","console","log","self","e","reader","getReader","read","context","then","result","done","value","prototype","_read","module","exports"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/iso-stream-http/lib/incoming-message.js"],"sourcesContent":["var capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar IncomingMessage = function (response, mode, fetchTimer) {\n\tstream.Readable.call(this)\n\n\tthis._mode = mode\n\tthis.headers = {}\n\tthis.rawHeaders = []\n\tthis.trailers = {}\n\tthis.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tthis.on('end',  () => {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(() =>this.emit('close'))\n\t})\n\n\tthis._fetchResponse = response\n\n\tthis.url = response.url\n\tthis.statusCode = response.status\n\tthis.statusMessage = response.statusText\n\t\n\tresponse.headers.forEach((header, key) => {\n\t\tthis.headers[key.toLowerCase()] = header\n\t\tthis.rawHeaders.push(key, header)\n\t})\n\n\tif (capability.writableStream) {\n\t\tvar writable = new WritableStream({\n\t\t\twrite: chunk => {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tif (this._destroyed) {\n\t\t\t\t\t\treject()\n\t\t\t\t\t} else if(this.push(Buffer.from(chunk))) {\n\t\t\t\t\t\tresolve()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._resumeFetch = resolve\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t},\n\t\t\tclose: () => {\n\t\t\t\tclearTimeout(fetchTimer)\n\t\t\t\tif (!this._destroyed){\n\t\t\t\t\tthis.push(null)\n\t\t\t\t}\n\t\t\t},\n\t\t\tabort: err => {\n\t\t\t\tif (!this._destroyed){\n\t\t\t\t\tthis.emit('error', err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\ttry {\n\t\t\tresponse.body\n\t\t\t\t.pipeTo(writable)\n\t\t\t\t.catch(err => {\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t\tself.clearTimeout(fetchTimer)\n\t\t\t\t\tif (!this._destroyed){\n\t\t\t\t\t\tthis.emit('error', err)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\treturn\n\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\t}\n\t// fallback for when writableStream or pipeTo aren't available\n\tvar reader = response.body.getReader()\n\t\n\tfunction read (context) {\n\t\treader.read()\n\t\t.then(result => {\n\t\t\tif (context._destroyed){\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (result.done) {\n\t\t\t\tclearTimeout(fetchTimer)\n\t\t\t\tcontext.push(null)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontext.push(Buffer.from(result.value))\n\t\t\tread(context)\n\t\t})\n\t\t.catch(err => {\n\t\t\tclearTimeout(fetchTimer)\n\t\t\tif (!context._destroyed){\n\t\t\t\tcontext.emit('error', err)\n\t\t\t}\n\t\t})\n\t}\n\n\tread(this)\n\t\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {\n\tvar resolve = this._resumeFetch\n\tif (resolve) {\n\t\tthis._resumeFetch = null\n\t\tresolve()\n\t}\n}\n\nmodule.exports = IncomingMessage"],"mappings":"AAAA,IAAIA,UAAU,GAAGC,OAAO,CAAC,cAAc,CAAC;AACxC,IAAIC,QAAQ,GAAGD,OAAO,CAAC,UAAU,CAAC;AAClC,IAAIE,MAAM,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAEvC,IAAIG,eAAe,GAAG,SAAAA,CAAUC,QAAQ,EAAEC,IAAI,EAAEC,UAAU,EAAE;EAC3DJ,MAAM,CAACK,QAAQ,CAACC,IAAI,CAAC,IAAI,CAAC;EAE1B,IAAI,CAACC,KAAK,GAAGJ,IAAI;EACjB,IAAI,CAACK,OAAO,GAAG,CAAC,CAAC;EACjB,IAAI,CAACC,UAAU,GAAG,EAAE;EACpB,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC;EAClB,IAAI,CAACC,WAAW,GAAG,EAAE;;EAErB;EACA,IAAI,CAACC,EAAE,CAAC,KAAK,EAAG,MAAM;IACrB;IACAC,OAAO,CAACC,QAAQ,CAAC,MAAK,IAAI,CAACC,IAAI,CAAC,OAAO,CAAC,CAAC;EAC1C,CAAC,CAAC;EAEF,IAAI,CAACC,cAAc,GAAGd,QAAQ;EAE9B,IAAI,CAACe,GAAG,GAAGf,QAAQ,CAACe,GAAG;EACvB,IAAI,CAACC,UAAU,GAAGhB,QAAQ,CAACiB,MAAM;EACjC,IAAI,CAACC,aAAa,GAAGlB,QAAQ,CAACmB,UAAU;EAExCnB,QAAQ,CAACM,OAAO,CAACc,OAAO,CAAC,CAACC,MAAM,EAAEC,GAAG,KAAK;IACzC,IAAI,CAAChB,OAAO,CAACgB,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC,GAAGF,MAAM;IACxC,IAAI,CAACd,UAAU,CAACiB,IAAI,CAACF,GAAG,EAAED,MAAM,CAAC;EAClC,CAAC,CAAC;EAEF,IAAI1B,UAAU,CAAC8B,cAAc,EAAE;IAC9B,IAAIC,QAAQ,GAAG,IAAIC,cAAc,CAAC;MACjCC,KAAK,EAAEC,KAAK,IAAI;QACf,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;UACvC,IAAI,IAAI,CAACC,UAAU,EAAE;YACpBD,MAAM,CAAC,CAAC;UACT,CAAC,MAAM,IAAG,IAAI,CAACR,IAAI,CAACU,MAAM,CAACC,IAAI,CAACN,KAAK,CAAC,CAAC,EAAE;YACxCE,OAAO,CAAC,CAAC;UACV,CAAC,MAAM;YACN,IAAI,CAACK,YAAY,GAAGL,OAAO;UAC5B;QACD,CAAC,CAAC;MACH,CAAC;MACDM,KAAK,EAAEA,CAAA,KAAM;QACZC,YAAY,CAACpC,UAAU,CAAC;QACxB,IAAI,CAAC,IAAI,CAAC+B,UAAU,EAAC;UACpB,IAAI,CAACT,IAAI,CAAC,IAAI,CAAC;QAChB;MACD,CAAC;MACDe,KAAK,EAAEC,GAAG,IAAI;QACb,IAAI,CAAC,IAAI,CAACP,UAAU,EAAC;UACpB,IAAI,CAACpB,IAAI,CAAC,OAAO,EAAE2B,GAAG,CAAC;QACxB;MACD;IACD,CAAC,CAAC;IAEF,IAAI;MACHxC,QAAQ,CAACyC,IAAI,CACXC,MAAM,CAAChB,QAAQ,CAAC,CAChBiB,KAAK,CAACH,GAAG,IAAI;QACbI,OAAO,CAACC,GAAG,CAACL,GAAG,CAAC;QAChBM,IAAI,CAACR,YAAY,CAACpC,UAAU,CAAC;QAC7B,IAAI,CAAC,IAAI,CAAC+B,UAAU,EAAC;UACpB,IAAI,CAACpB,IAAI,CAAC,OAAO,EAAE2B,GAAG,CAAC;QACxB;MACD,CAAC,CAAC;MACH;IACD,CAAC,CAAC,OAAOO,CAAC,EAAE,CAAC,CAAC,CAAC;EAChB;EACA;EACA,IAAIC,MAAM,GAAGhD,QAAQ,CAACyC,IAAI,CAACQ,SAAS,CAAC,CAAC;EAEtC,SAASC,IAAIA,CAAEC,OAAO,EAAE;IACvBH,MAAM,CAACE,IAAI,CAAC,CAAC,CACZE,IAAI,CAACC,MAAM,IAAI;MACf,IAAIF,OAAO,CAAClB,UAAU,EAAC;QACtB;MACD;MACA,IAAIoB,MAAM,CAACC,IAAI,EAAE;QAChBhB,YAAY,CAACpC,UAAU,CAAC;QACxBiD,OAAO,CAAC3B,IAAI,CAAC,IAAI,CAAC;QAClB;MACD;MACA2B,OAAO,CAAC3B,IAAI,CAACU,MAAM,CAACC,IAAI,CAACkB,MAAM,CAACE,KAAK,CAAC,CAAC;MACvCL,IAAI,CAACC,OAAO,CAAC;IACd,CAAC,CAAC,CACDR,KAAK,CAACH,GAAG,IAAI;MACbF,YAAY,CAACpC,UAAU,CAAC;MACxB,IAAI,CAACiD,OAAO,CAAClB,UAAU,EAAC;QACvBkB,OAAO,CAACtC,IAAI,CAAC,OAAO,EAAE2B,GAAG,CAAC;MAC3B;IACD,CAAC,CAAC;EACH;EAEAU,IAAI,CAAC,IAAI,CAAC;AAEX,CAAC;AAEDrD,QAAQ,CAACE,eAAe,EAAED,MAAM,CAACK,QAAQ,CAAC;AAE1CJ,eAAe,CAACyD,SAAS,CAACC,KAAK,GAAG,YAAY;EAC7C,IAAI1B,OAAO,GAAG,IAAI,CAACK,YAAY;EAC/B,IAAIL,OAAO,EAAE;IACZ,IAAI,CAACK,YAAY,GAAG,IAAI;IACxBL,OAAO,CAAC,CAAC;EACV;AACD,CAAC;AAED2B,MAAM,CAACC,OAAO,GAAG5D,eAAe"},"metadata":{},"sourceType":"script"}