{"ast":null,"code":"'use strict';\n\nconst webcrypto = require('../webcrypto');\nconst nodeify = require('../nodeify');\nconst BN = require('asn1.js').bignum;\nconst util = require('../util');\nconst toBase64 = util.toBase64;\nconst toBn = util.toBn;\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n};\nexports.generateEphmeralKeyPair = function (curve, callback) {\n  nodeify(webcrypto.subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: curve\n  }, true, ['deriveBits']).then(pair => {\n    // forcePrivate is used for testing only\n    const genSharedKey = (theirPub, forcePrivate, cb) => {\n      if (typeof forcePrivate === 'function') {\n        cb = forcePrivate;\n        forcePrivate = undefined;\n      }\n      let privateKey;\n      if (forcePrivate) {\n        privateKey = webcrypto.subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n          name: 'ECDH',\n          namedCurve: curve\n        }, false, ['deriveBits']);\n      } else {\n        privateKey = Promise.resolve(pair.privateKey);\n      }\n      const keys = Promise.all([webcrypto.subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n        name: 'ECDH',\n        namedCurve: curve\n      }, false, []), privateKey]);\n      nodeify(keys.then(keys => webcrypto.subtle.deriveBits({\n        name: 'ECDH',\n        namedCurve: curve,\n        public: keys[0]\n      }, keys[1], bits[curve])).then(bits => Buffer.from(bits)), cb);\n    };\n    return webcrypto.subtle.exportKey('jwk', pair.publicKey).then(publicKey => {\n      return {\n        key: marshalPublicKey(publicKey),\n        genSharedKey\n      };\n    });\n  }), callback);\n};\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n};\n\n// Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey(jwk) {\n  const byteLen = curveLengths[jwk.crv];\n  return Buffer.concat([Buffer.from([4]),\n  // uncompressed point\n  toBn(jwk.x).toArrayLike(Buffer, 'be', byteLen), toBn(jwk.y).toArrayLike(Buffer, 'be', byteLen)], 1 + byteLen * 2);\n}\n\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey(curve, key) {\n  const byteLen = curveLengths[curve];\n  if (!key.slice(0, 1).equals(Buffer.from([4]))) {\n    throw new Error('Invalid key format');\n  }\n  const x = new BN(key.slice(1, byteLen + 1));\n  const y = new BN(key.slice(1 + byteLen));\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: toBase64(x, byteLen),\n    y: toBase64(y, byteLen),\n    ext: true\n  };\n}\nfunction unmarshalPrivateKey(curve, key) {\n  const result = unmarshalPublicKey(curve, key.public);\n  result.d = toBase64(new BN(key.private));\n  return result;\n}","map":{"version":3,"names":["webcrypto","require","nodeify","BN","bignum","util","toBase64","toBn","bits","exports","generateEphmeralKeyPair","curve","callback","subtle","generateKey","name","namedCurve","then","pair","genSharedKey","theirPub","forcePrivate","cb","undefined","privateKey","importKey","unmarshalPrivateKey","Promise","resolve","keys","all","unmarshalPublicKey","deriveBits","public","Buffer","from","exportKey","publicKey","key","marshalPublicKey","curveLengths","jwk","byteLen","crv","concat","x","toArrayLike","y","slice","equals","Error","kty","ext","result","d","private"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/libp2p-crypto/src/keys/ecdh-browser.js"],"sourcesContent":["'use strict'\n\nconst webcrypto = require('../webcrypto')\nconst nodeify = require('../nodeify')\nconst BN = require('asn1.js').bignum\n\nconst util = require('../util')\nconst toBase64 = util.toBase64\nconst toBn = util.toBn\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n}\n\nexports.generateEphmeralKeyPair = function (curve, callback) {\n  nodeify(webcrypto.subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  ).then((pair) => {\n    // forcePrivate is used for testing only\n    const genSharedKey = (theirPub, forcePrivate, cb) => {\n      if (typeof forcePrivate === 'function') {\n        cb = forcePrivate\n        forcePrivate = undefined\n      }\n\n      let privateKey\n\n      if (forcePrivate) {\n        privateKey = webcrypto.subtle.importKey(\n          'jwk',\n          unmarshalPrivateKey(curve, forcePrivate),\n          {\n            name: 'ECDH',\n            namedCurve: curve\n          },\n          false,\n          ['deriveBits']\n        )\n      } else {\n        privateKey = Promise.resolve(pair.privateKey)\n      }\n\n      const keys = Promise.all([\n        webcrypto.subtle.importKey(\n          'jwk',\n          unmarshalPublicKey(curve, theirPub),\n          {\n            name: 'ECDH',\n            namedCurve: curve\n          },\n          false,\n          []\n        ),\n        privateKey\n      ])\n\n      nodeify(keys.then((keys) => webcrypto.subtle.deriveBits(\n        {\n          name: 'ECDH',\n          namedCurve: curve,\n          public: keys[0]\n        },\n        keys[1],\n        bits[curve]\n      )).then((bits) => Buffer.from(bits)), cb)\n    }\n\n    return webcrypto.subtle.exportKey('jwk', pair.publicKey)\n      .then((publicKey) => {\n        return {\n          key: marshalPublicKey(publicKey),\n          genSharedKey\n        }\n      })\n  }), callback)\n}\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\n// Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk) {\n  const byteLen = curveLengths[jwk.crv]\n\n  return Buffer.concat([\n    Buffer.from([4]), // uncompressed point\n    toBn(jwk.x).toArrayLike(Buffer, 'be', byteLen),\n    toBn(jwk.y).toArrayLike(Buffer, 'be', byteLen)\n  ], 1 + byteLen * 2)\n}\n\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey (curve, key) {\n  const byteLen = curveLengths[curve]\n\n  if (!key.slice(0, 1).equals(Buffer.from([4]))) {\n    throw new Error('Invalid key format')\n  }\n  const x = new BN(key.slice(1, byteLen + 1))\n  const y = new BN(key.slice(1 + byteLen))\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: toBase64(x, byteLen),\n    y: toBase64(y, byteLen),\n    ext: true\n  }\n}\n\nfunction unmarshalPrivateKey (curve, key) {\n  const result = unmarshalPublicKey(curve, key.public)\n  result.d = toBase64(new BN(key.private))\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}