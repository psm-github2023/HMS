{"ast":null,"code":"/* eslint-disable guard-for-in */\n/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst multibase = require('multibase');\nconst varint = require('varint');\nconst {\n  names\n} = require('./constants');\nconst codes = {};\nfor (const key in names) {\n  codes[names[key]] = key;\n}\nexports.names = names;\nexports.codes = Object.freeze(codes);\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toHexString = function toHexString(hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer');\n  }\n  return hash.toString('hex');\n};\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Buffer}\n */\nexports.fromHexString = function fromHexString(hash) {\n  return Buffer.from(hash, 'hex');\n};\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toB58String = function toB58String(hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer');\n  }\n  return multibase.encode('base58btc', hash).toString().slice(1);\n};\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Buffer} hash\n * @returns {Buffer}\n */\nexports.fromB58String = function fromB58String(hash) {\n  let encoded = hash;\n  if (Buffer.isBuffer(hash)) {\n    encoded = hash.toString();\n  }\n  return multibase.decode('z' + encoded);\n};\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Buffer} buf\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\n */\nexports.decode = function decode(buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('multihash must be a Buffer');\n  }\n  if (buf.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.');\n  }\n  const code = varint.decode(buf);\n  if (!exports.isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);\n  }\n  buf = buf.slice(varint.decode.bytes);\n  const len = varint.decode(buf);\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`);\n  }\n  buf = buf.slice(varint.decode.bytes);\n  if (buf.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`);\n  }\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: buf\n  };\n};\n\n/**\n *  Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Buffer} digest\n * @param {string|number} code\n * @param {number} [length]\n * @returns {Buffer}\n */\nexports.encode = function encode(digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code');\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = exports.coerceCode(code);\n  if (!Buffer.isBuffer(digest)) {\n    throw new Error('digest should be a Buffer');\n  }\n  if (length == null) {\n    length = digest.length;\n  }\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.');\n  }\n  return Buffer.concat([Buffer.from(varint.encode(hashfn)), Buffer.from(varint.encode(length)), digest]);\n};\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n * @param {string|number} name\n * @returns {number}\n */\nexports.coerceCode = function coerceCode(name) {\n  let code = name;\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`);\n    }\n    code = names[name];\n  }\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`);\n  }\n  if (codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`);\n  }\n  return code;\n};\n\n/**\n * Checks wether a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isAppCode = function appCode(code) {\n  return code > 0 && code < 0x10;\n};\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isValidCode = function validCode(code) {\n  if (exports.isAppCode(code)) {\n    return true;\n  }\n  if (codes[code]) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nfunction validate(multihash) {\n  exports.decode(multihash); // throws if bad.\n}\n\nexports.validate = validate;\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nexports.prefix = function prefix(multihash) {\n  validate(multihash);\n  return multihash.slice(0, 2);\n};","map":{"version":3,"names":["Buffer","require","multibase","varint","names","codes","key","exports","Object","freeze","toHexString","hash","isBuffer","Error","toString","fromHexString","from","toB58String","encode","slice","fromB58String","encoded","decode","buf","length","code","isValidCode","bytes","len","name","digest","undefined","hashfn","coerceCode","concat","isAppCode","appCode","validCode","validate","multihash","prefix"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/ipld-dag-cbor/node_modules/multihashes/src/index.js"],"sourcesContent":["/* eslint-disable guard-for-in */\n/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict'\n\nconst { Buffer } = require('buffer')\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst { names } = require('./constants')\n\nconst codes = {}\n\nfor (const key in names) {\n  codes[names[key]] = key\n}\nexports.names = names\nexports.codes = Object.freeze(codes)\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toHexString = function toHexString (hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer')\n  }\n\n  return hash.toString('hex')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Buffer}\n */\nexports.fromHexString = function fromHexString (hash) {\n  return Buffer.from(hash, 'hex')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toB58String = function toB58String (hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer')\n  }\n\n  return multibase.encode('base58btc', hash).toString().slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Buffer} hash\n * @returns {Buffer}\n */\nexports.fromB58String = function fromB58String (hash) {\n  let encoded = hash\n  if (Buffer.isBuffer(hash)) {\n    encoded = hash.toString()\n  }\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Buffer} buf\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\n */\nexports.decode = function decode (buf) {\n  if (!(Buffer.isBuffer(buf))) {\n    throw new Error('multihash must be a Buffer')\n  }\n\n  if (buf.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = varint.decode(buf)\n  if (!exports.isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  const len = varint.decode(buf)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: buf\n  }\n}\n\n/**\n *  Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Buffer} digest\n * @param {string|number} code\n * @param {number} [length]\n * @returns {Buffer}\n */\nexports.encode = function encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = exports.coerceCode(code)\n\n  if (!(Buffer.isBuffer(digest))) {\n    throw new Error('digest should be a Buffer')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  return Buffer.concat([\n    Buffer.from(varint.encode(hashfn)),\n    Buffer.from(varint.encode(length)),\n    digest\n  ])\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n * @param {string|number} name\n * @returns {number}\n */\nexports.coerceCode = function coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  if (codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks wether a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isAppCode = function appCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isValidCode = function validCode (code) {\n  if (exports.isAppCode(code)) {\n    return true\n  }\n\n  if (codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  exports.decode(multihash) // throws if bad.\n}\nexports.validate = validate\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nexports.prefix = function prefix (multihash) {\n  validate(multihash)\n\n  return multihash.slice(0, 2)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}