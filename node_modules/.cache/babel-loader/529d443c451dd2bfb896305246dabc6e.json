{"ast":null,"code":"'use strict';\n\nconst protobuf = require('protons');\nconst keysPBM = protobuf(require('./keys.proto'));\nrequire('node-forge/lib/asn1');\nrequire('node-forge/lib/rsa');\nrequire('node-forge/lib/pbe');\nconst forge = require('node-forge/lib/forge');\nexports = module.exports;\nconst supportedKeys = {\n  rsa: require('./rsa-class'),\n  ed25519: require('./ed25519-class'),\n  secp256k1: require('libp2p-crypto-secp256k1')(keysPBM, require('../random-bytes'))\n};\nexports.supportedKeys = supportedKeys;\nexports.keysPBM = keysPBM;\nfunction isValidKeyType(keyType) {\n  const key = supportedKeys[keyType.toLowerCase()];\n  return key !== undefined;\n}\nexports.keyStretcher = require('./key-stretcher');\nexports.generateEphemeralKeyPair = require('./ephemeral-keys');\n\n// Generates a keypair of the given type and bitsize\nexports.generateKeyPair = (type, bits, cb) => {\n  const key = supportedKeys[type.toLowerCase()];\n  if (!key) {\n    return cb(new Error('invalid or unsupported key type'));\n  }\n  key.generateKeyPair(bits, cb);\n};\n\n// Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\nexports.generateKeyPairFromSeed = (type, seed, bits, cb) => {\n  const key = supportedKeys[type.toLowerCase()];\n  if (!key) {\n    return cb(new Error('invalid or unsupported key type'));\n  }\n  if (type.toLowerCase() !== 'ed25519') {\n    return cb(new Error('Seed key derivation is unimplemented for RSA or secp256k1'));\n  }\n  key.generateKeyPairFromSeed(seed, bits, cb);\n};\n\n// Converts a protobuf serialized public key into its\n// representative object\nexports.unmarshalPublicKey = buf => {\n  const decoded = keysPBM.PublicKey.decode(buf);\n  const data = decoded.Data;\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data);\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);\n      } else {\n        throw new Error('secp256k1 support requires libp2p-crypto-secp256k1 package');\n      }\n    default:\n      throw new Error('invalid or unsupported key type');\n  }\n};\n\n// Converts a public key object into a protobuf serialized public key\nexports.marshalPublicKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase();\n  if (!isValidKeyType(type)) {\n    throw new Error('invalid or unsupported key type');\n  }\n  return key.bytes;\n};\n\n// Converts a protobuf serialized private key into its\n// representative object\nexports.unmarshalPrivateKey = (buf, callback) => {\n  let decoded;\n  try {\n    decoded = keysPBM.PrivateKey.decode(buf);\n  } catch (err) {\n    return callback(err);\n  }\n  const data = decoded.Data;\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPrivateKey(data, callback);\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data, callback);\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data, callback);\n      } else {\n        return callback(new Error('secp256k1 support requires libp2p-crypto-secp256k1 package'));\n      }\n    default:\n      callback(new Error('invalid or unsupported key type'));\n  }\n};\n\n// Converts a private key object into a protobuf serialized private key\nexports.marshalPrivateKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase();\n  if (!isValidKeyType(type)) {\n    throw new Error('invalid or unsupported key type');\n  }\n  return key.bytes;\n};\nexports.import = (pem, password, callback) => {\n  try {\n    const key = forge.pki.decryptRsaPrivateKey(pem, password);\n    if (key === null) {\n      throw new Error('Cannot read the key, most likely the password is wrong or not a RSA key');\n    }\n    let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));\n    der = Buffer.from(der.getBytes(), 'binary');\n    return supportedKeys.rsa.unmarshalRsaPrivateKey(der, callback);\n  } catch (err) {\n    callback(err);\n  }\n};","map":{"version":3,"names":["protobuf","require","keysPBM","forge","exports","module","supportedKeys","rsa","ed25519","secp256k1","isValidKeyType","keyType","key","toLowerCase","undefined","keyStretcher","generateEphemeralKeyPair","generateKeyPair","type","bits","cb","Error","generateKeyPairFromSeed","seed","unmarshalPublicKey","buf","decoded","PublicKey","decode","data","Data","Type","KeyType","RSA","unmarshalRsaPublicKey","Ed25519","unmarshalEd25519PublicKey","Secp256k1","unmarshalSecp256k1PublicKey","marshalPublicKey","bytes","unmarshalPrivateKey","callback","PrivateKey","err","unmarshalRsaPrivateKey","unmarshalEd25519PrivateKey","unmarshalSecp256k1PrivateKey","marshalPrivateKey","import","pem","password","pki","decryptRsaPrivateKey","der","asn1","toDer","privateKeyToAsn1","Buffer","from","getBytes"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/libp2p-crypto/src/keys/index.js"],"sourcesContent":["'use strict'\n\nconst protobuf = require('protons')\nconst keysPBM = protobuf(require('./keys.proto'))\nrequire('node-forge/lib/asn1')\nrequire('node-forge/lib/rsa')\nrequire('node-forge/lib/pbe')\nconst forge = require('node-forge/lib/forge')\n\nexports = module.exports\n\nconst supportedKeys = {\n  rsa: require('./rsa-class'),\n  ed25519: require('./ed25519-class'),\n  secp256k1: require('libp2p-crypto-secp256k1')(keysPBM, require('../random-bytes'))\n}\n\nexports.supportedKeys = supportedKeys\nexports.keysPBM = keysPBM\n\nfunction isValidKeyType (keyType) {\n  const key = supportedKeys[keyType.toLowerCase()]\n  return key !== undefined\n}\n\nexports.keyStretcher = require('./key-stretcher')\nexports.generateEphemeralKeyPair = require('./ephemeral-keys')\n\n// Generates a keypair of the given type and bitsize\nexports.generateKeyPair = (type, bits, cb) => {\n  const key = supportedKeys[type.toLowerCase()]\n\n  if (!key) {\n    return cb(new Error('invalid or unsupported key type'))\n  }\n\n  key.generateKeyPair(bits, cb)\n}\n\n// Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\nexports.generateKeyPairFromSeed = (type, seed, bits, cb) => {\n  const key = supportedKeys[type.toLowerCase()]\n  if (!key) {\n    return cb(new Error('invalid or unsupported key type'))\n  }\n  if (type.toLowerCase() !== 'ed25519') {\n    return cb(new Error('Seed key derivation is unimplemented for RSA or secp256k1'))\n  }\n  key.generateKeyPairFromSeed(seed, bits, cb)\n}\n\n// Converts a protobuf serialized public key into its\n// representative object\nexports.unmarshalPublicKey = (buf) => {\n  const decoded = keysPBM.PublicKey.decode(buf)\n  const data = decoded.Data\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data)\n      } else {\n        throw new Error('secp256k1 support requires libp2p-crypto-secp256k1 package')\n      }\n    default:\n      throw new Error('invalid or unsupported key type')\n  }\n}\n\n// Converts a public key object into a protobuf serialized public key\nexports.marshalPublicKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase()\n  if (!isValidKeyType(type)) {\n    throw new Error('invalid or unsupported key type')\n  }\n\n  return key.bytes\n}\n\n// Converts a protobuf serialized private key into its\n// representative object\nexports.unmarshalPrivateKey = (buf, callback) => {\n  let decoded\n  try {\n    decoded = keysPBM.PrivateKey.decode(buf)\n  } catch (err) {\n    return callback(err)\n  }\n\n  const data = decoded.Data\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPrivateKey(data, callback)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data, callback)\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data, callback)\n      } else {\n        return callback(new Error('secp256k1 support requires libp2p-crypto-secp256k1 package'))\n      }\n    default:\n      callback(new Error('invalid or unsupported key type'))\n  }\n}\n\n// Converts a private key object into a protobuf serialized private key\nexports.marshalPrivateKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase()\n  if (!isValidKeyType(type)) {\n    throw new Error('invalid or unsupported key type')\n  }\n\n  return key.bytes\n}\n\nexports.import = (pem, password, callback) => {\n  try {\n    const key = forge.pki.decryptRsaPrivateKey(pem, password)\n    if (key === null) {\n      throw new Error('Cannot read the key, most likely the password is wrong or not a RSA key')\n    }\n    let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key))\n    der = Buffer.from(der.getBytes(), 'binary')\n    return supportedKeys.rsa.unmarshalRsaPrivateKey(der, callback)\n  } catch (err) {\n    callback(err)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}