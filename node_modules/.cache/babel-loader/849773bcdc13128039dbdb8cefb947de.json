{"ast":null,"code":"'use strict';\n\nconst multihashing = require('multihashing-async');\nconst protobuf = require('protons');\nconst bs58 = require('bs58');\nconst nextTick = require('async/nextTick');\nconst crypto = require('./rsa');\nconst pbm = protobuf(require('./keys.proto'));\nrequire('node-forge/lib/sha512');\nrequire('node-forge/lib/pbe');\nconst forge = require('node-forge/lib/forge');\nclass RsaPublicKey {\n  constructor(key) {\n    this._key = key;\n  }\n  verify(data, sig, callback) {\n    ensure(callback);\n    crypto.hashAndVerify(this._key, sig, data, callback);\n  }\n  marshal() {\n    return crypto.utils.jwkToPkix(this._key);\n  }\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    });\n  }\n  encrypt(bytes, cb) {\n    return cbWrap(() => crypto.encrypt(this._key, bytes), cb);\n  }\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n  hash(callback) {\n    ensure(callback);\n    multihashing(this.bytes, 'sha2-256', callback);\n  }\n}\nfunction cbWrap(f, cb) {\n  let res;\n  try {\n    res = f();\n  } catch (err) {\n    cb(err);\n  }\n  return cb(null, res);\n}\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Buffer of the spki format\n  constructor(key, publicKey) {\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n  genSecret() {\n    return crypto.getRandomValues(16);\n  }\n  sign(message, callback) {\n    ensure(callback);\n    crypto.hashAndSign(this._key, message, callback);\n  }\n  get public() {\n    if (!this._publicKey) {\n      throw new Error('public key not provided');\n    }\n    return new RsaPublicKey(this._publicKey);\n  }\n  decrypt(bytes, cb) {\n    cbWrap(() => crypto.decrypt(this._key, bytes), cb);\n  }\n  marshal() {\n    return crypto.utils.jwkToPkcs1(this._key);\n  }\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    });\n  }\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n  hash(callback) {\n    ensure(callback);\n    multihashing(this.bytes, 'sha2-256', callback);\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @param {function(Error, id)} callback\n   * @returns {undefined}\n   */\n  id(callback) {\n    this.public.hash((err, hash) => {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, bs58.encode(hash));\n    });\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} [format] - Defaults to 'pkcs-8'.\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n  export(format, password, callback) {\n    if (typeof password === 'function') {\n      callback = password;\n      password = format;\n      format = 'pkcs-8';\n    }\n    ensure(callback);\n    nextTick(() => {\n      let err = null;\n      let pem = null;\n      try {\n        const buffer = new forge.util.ByteBuffer(this.marshal());\n        const asn1 = forge.asn1.fromDer(buffer);\n        const privateKey = forge.pki.privateKeyFromAsn1(asn1);\n        if (format === 'pkcs-8') {\n          const options = {\n            algorithm: 'aes256',\n            count: 10000,\n            saltSize: 128 / 8,\n            prfAlgorithm: 'sha512'\n          };\n          pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options);\n        } else {\n          err = new Error(`Unknown export format '${format}'`);\n        }\n      } catch (_err) {\n        err = _err;\n      }\n      callback(err, pem);\n    });\n  }\n}\nfunction unmarshalRsaPrivateKey(bytes, callback) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes);\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\nfunction unmarshalRsaPublicKey(bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\nfunction fromJwk(jwk, callback) {\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\nfunction generateKeyPair(bits, callback) {\n  crypto.generateKey(bits, (err, keys) => {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\nfunction ensure(callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n}\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n};","map":{"version":3,"names":["multihashing","require","protobuf","bs58","nextTick","crypto","pbm","forge","RsaPublicKey","constructor","key","_key","verify","data","sig","callback","ensure","hashAndVerify","marshal","utils","jwkToPkix","bytes","PublicKey","encode","Type","KeyType","RSA","Data","encrypt","cb","cbWrap","equals","hash","f","res","err","RsaPrivateKey","publicKey","_publicKey","genSecret","getRandomValues","sign","message","hashAndSign","public","Error","decrypt","jwkToPkcs1","PrivateKey","id","export","format","password","pem","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","_err","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","unmarshalPrivateKey","keys","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey","module","exports"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/libp2p-crypto/src/keys/rsa-class.js"],"sourcesContent":["'use strict'\n\nconst multihashing = require('multihashing-async')\nconst protobuf = require('protons')\nconst bs58 = require('bs58')\nconst nextTick = require('async/nextTick')\n\nconst crypto = require('./rsa')\nconst pbm = protobuf(require('./keys.proto'))\nrequire('node-forge/lib/sha512')\nrequire('node-forge/lib/pbe')\nconst forge = require('node-forge/lib/forge')\n\nclass RsaPublicKey {\n  constructor (key) {\n    this._key = key\n  }\n\n  verify (data, sig, callback) {\n    ensure(callback)\n    crypto.hashAndVerify(this._key, sig, data, callback)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    })\n  }\n\n  encrypt (bytes, cb) {\n    return cbWrap(() => crypto.encrypt(this._key, bytes), cb)\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  hash (callback) {\n    ensure(callback)\n    multihashing(this.bytes, 'sha2-256', callback)\n  }\n}\n\nfunction cbWrap (f, cb) {\n  let res\n  try {\n    res = f()\n  } catch (err) {\n    cb(err)\n  }\n\n  return cb(null, res)\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Buffer of the spki format\n  constructor (key, publicKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret () {\n    return crypto.getRandomValues(16)\n  }\n\n  sign (message, callback) {\n    ensure(callback)\n    crypto.hashAndSign(this._key, message, callback)\n  }\n\n  get public () {\n    if (!this._publicKey) {\n      throw new Error('public key not provided')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (bytes, cb) {\n    cbWrap(() => crypto.decrypt(this._key, bytes), cb)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  hash (callback) {\n    ensure(callback)\n    multihashing(this.bytes, 'sha2-256', callback)\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @param {function(Error, id)} callback\n   * @returns {undefined}\n   */\n  id (callback) {\n    this.public.hash((err, hash) => {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, bs58.encode(hash))\n    })\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} [format] - Defaults to 'pkcs-8'.\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n  export (format, password, callback) {\n    if (typeof password === 'function') {\n      callback = password\n      password = format\n      format = 'pkcs-8'\n    }\n\n    ensure(callback)\n\n    nextTick(() => {\n      let err = null\n      let pem = null\n      try {\n        const buffer = new forge.util.ByteBuffer(this.marshal())\n        const asn1 = forge.asn1.fromDer(buffer)\n        const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n        if (format === 'pkcs-8') {\n          const options = {\n            algorithm: 'aes256',\n            count: 10000,\n            saltSize: 128 / 8,\n            prfAlgorithm: 'sha512'\n          }\n          pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n        } else {\n          err = new Error(`Unknown export format '${format}'`)\n        }\n      } catch (_err) {\n        err = _err\n      }\n\n      callback(err, pem)\n    })\n  }\n}\n\nfunction unmarshalRsaPrivateKey (bytes, callback) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\n  })\n}\n\nfunction unmarshalRsaPublicKey (bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n\n  return new RsaPublicKey(jwk)\n}\n\nfunction fromJwk (jwk, callback) {\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\n  })\n}\n\nfunction generateKeyPair (bits, callback) {\n  crypto.generateKey(bits, (err, keys) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\n  })\n}\n\nfunction ensure (callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}