{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\nconst protons = require('protons');\nconst proto = protons(require('./dag.proto.js'));\nconst DAGLink = require('./dag-link');\nconst DAGNode = require('./dag-node');\nconst multicodec = require('multicodec');\nconst multihashing = require('multihashing-async');\nexports = module.exports;\nexports.codec = multicodec.DAG_PB;\nexports.defaultHashAlg = multicodec.SHA2_256;\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\nconst cid = async (binaryBlob, userOptions) => {\n  const defaultOptions = {\n    cidVersion: 1,\n    hashAlg: exports.defaultHashAlg\n  };\n  const options = Object.assign(defaultOptions, userOptions);\n  const multihash = await multihashing(binaryBlob, options.hashAlg);\n  const codecName = multicodec.print[exports.codec];\n  const cid = new CID(options.cidVersion, codecName, multihash);\n  return cid;\n};\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Buffer} - The encoded binary representation\n */\nconst serialize = node => {\n  let data = node.Data;\n  let links = node.Links || [];\n\n  // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n  if (!DAGNode.isDAGNode(node) && links) {\n    links = links.map(link => {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);\n    });\n  }\n  const serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }));\n  return serialized;\n};\n\n/**\n * Deserialize PB block into the internal representation.\n *\n * @param {Buffer} buffer - Binary representation of a PB block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\nconst deserialize = buffer => {\n  const pbn = proto.PBNode.decode(buffer);\n  const links = pbn.Links.map(link => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash);\n  });\n  const data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data;\n  return new DAGNode(data, links, buffer.length);\n};\nfunction toProtoBuf(node) {\n  const pbn = {};\n  if (node.Data && node.Data.length > 0) {\n    pbn.Data = node.Data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null;\n  }\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links.map(link => ({\n      Hash: link.Hash.buffer,\n      Name: link.Name,\n      Tsize: link.Tsize\n    }));\n  } else {\n    pbn.Links = null;\n  }\n  return pbn;\n}\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.cid = cid;","map":{"version":3,"names":["CID","require","protons","proto","DAGLink","DAGNode","multicodec","multihashing","exports","module","codec","DAG_PB","defaultHashAlg","SHA2_256","cid","binaryBlob","userOptions","defaultOptions","cidVersion","hashAlg","options","Object","assign","multihash","codecName","print","serialize","node","data","Data","links","Links","isDAGNode","map","link","isDAGLink","util","createDagLinkFromB58EncodedHash","serialized","PBNode","encode","toProtoBuf","deserialize","buffer","pbn","decode","Name","Tsize","Hash","Buffer","alloc","length"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/ipld-dag-pb/src/util.js"],"sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst protons = require('protons')\nconst proto = protons(require('./dag.proto.js'))\nconst DAGLink = require('./dag-link')\nconst DAGNode = require('./dag-node')\nconst multicodec = require('multicodec')\nconst multihashing = require('multihashing-async')\n\nexports = module.exports\n\nexports.codec = multicodec.DAG_PB\nexports.defaultHashAlg = multicodec.SHA2_256\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\nconst cid = async (binaryBlob, userOptions) => {\n  const defaultOptions = { cidVersion: 1, hashAlg: exports.defaultHashAlg }\n  const options = Object.assign(defaultOptions, userOptions)\n\n  const multihash = await multihashing(binaryBlob, options.hashAlg)\n  const codecName = multicodec.print[exports.codec]\n  const cid = new CID(options.cidVersion, codecName, multihash)\n\n  return cid\n}\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Buffer} - The encoded binary representation\n */\nconst serialize = (node) => {\n  let data = node.Data\n  let links = node.Links || []\n\n  // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n  if (!DAGNode.isDAGNode(node) && links) {\n    links = links.map((link) => {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link)\n    })\n  }\n\n  const serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }))\n\n  return serialized\n}\n\n/**\n * Deserialize PB block into the internal representation.\n *\n * @param {Buffer} buffer - Binary representation of a PB block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\nconst deserialize = (buffer) => {\n  const pbn = proto.PBNode.decode(buffer)\n\n  const links = pbn.Links.map((link) => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash)\n  })\n\n  const data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data\n\n  return new DAGNode(data, links, buffer.length)\n}\n\nfunction toProtoBuf (node) {\n  const pbn = {}\n\n  if (node.Data && node.Data.length > 0) {\n    pbn.Data = node.Data\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links\n      .map((link) => ({\n        Hash: link.Hash.buffer,\n        Name: link.Name,\n        Tsize: link.Tsize\n      }))\n  } else {\n    pbn.Links = null\n  }\n\n  return pbn\n}\n\nexports.serialize = serialize\nexports.deserialize = deserialize\nexports.cid = cid\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}