{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\nconst withIs = require('class-is');\nconst addNamedLink = require('./addNamedLink');\nconst visibility = require('../visibility');\nclass DAGNode {\n  constructor(data, links, serializedSize) {\n    if (serializedSize !== 0) {\n      assert(serializedSize, 'A DAGNode requires it\\'s serialized size');\n    }\n    this._data = data || Buffer.alloc(0);\n    this._links = links;\n    this._serializedSize = serializedSize;\n\n    // Make sure we have a nice public API that can be used by an IPLD resolver\n    visibility.hidePrivateFields(this);\n    visibility.addEnumerableGetters(this, ['Data', 'Links']);\n\n    // Add getters for existing links by the name of the link\n    // This is how paths are traversed in IPFS. Links with names won't\n    // override existing fields like `data` or `links`.\n    links.forEach((link, position) => {\n      addNamedLink(this, link.Name, position);\n    });\n  }\n  toJSON() {\n    if (!this._json) {\n      this._json = Object.freeze({\n        data: this.Data,\n        links: this._links.map(l => l.toJSON()),\n        size: this.size\n      });\n    }\n    return Object.assign({}, this._json);\n  }\n  toString() {\n    return `DAGNode <data: \"${this.Data.toString('base64')}\", links: ${this.Links.length}, size: ${this.size}>`;\n  }\n  get size() {\n    if (this._size === undefined) {\n      this._size = this._links.reduce((sum, l) => sum + l.Tsize, this._serializedSize);\n    }\n    return this._size;\n  }\n  set size(size) {\n    throw new Error(\"Can't set property: 'size' is immutable\");\n  }\n\n  // Getters for backwards compatible path resolving\n  get Data() {\n    return this._data;\n  }\n  set Data(_) {\n    throw new Error(\"Can't set property: 'Data' is immutable\");\n  }\n  get Links() {\n    return this._links.map(link => {\n      return {\n        Name: link.Name,\n        Tsize: link.Tsize,\n        Hash: link.Hash\n      };\n    });\n  }\n  set Links(_) {\n    throw new Error(\"Can't set property: 'Links' is immutable\");\n  }\n}\nexports = module.exports = withIs(DAGNode, {\n  className: 'DAGNode',\n  symbolName: '@ipld/js-ipld-dag-pb/dagnode'\n});\nexports.create = require('./create');\nexports.clone = require('./clone');\nexports.addLink = require('./addLink');\nexports.rmLink = require('./rmLink');","map":{"version":3,"names":["assert","require","withIs","addNamedLink","visibility","DAGNode","constructor","data","links","serializedSize","_data","Buffer","alloc","_links","_serializedSize","hidePrivateFields","addEnumerableGetters","forEach","link","position","Name","toJSON","_json","Object","freeze","Data","map","l","size","assign","toString","Links","length","_size","undefined","reduce","sum","Tsize","Error","_","Hash","exports","module","className","symbolName","create","clone","addLink","rmLink"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/ipld-dag-pb/src/dag-node/index.js"],"sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst withIs = require('class-is')\nconst addNamedLink = require('./addNamedLink')\nconst visibility = require('../visibility')\n\nclass DAGNode {\n  constructor (data, links, serializedSize) {\n    if (serializedSize !== 0) {\n      assert(serializedSize, 'A DAGNode requires it\\'s serialized size')\n    }\n\n    this._data = data || Buffer.alloc(0)\n    this._links = links\n    this._serializedSize = serializedSize\n\n    // Make sure we have a nice public API that can be used by an IPLD resolver\n    visibility.hidePrivateFields(this)\n    visibility.addEnumerableGetters(this, ['Data', 'Links'])\n\n    // Add getters for existing links by the name of the link\n    // This is how paths are traversed in IPFS. Links with names won't\n    // override existing fields like `data` or `links`.\n    links.forEach((link, position) => {\n      addNamedLink(this, link.Name, position)\n    })\n  }\n\n  toJSON () {\n    if (!this._json) {\n      this._json = Object.freeze({\n        data: this.Data,\n        links: this._links.map((l) => l.toJSON()),\n        size: this.size\n      })\n    }\n\n    return Object.assign({}, this._json)\n  }\n\n  toString () {\n    return `DAGNode <data: \"${this.Data.toString('base64')}\", links: ${this.Links.length}, size: ${this.size}>`\n  }\n\n  get size () {\n    if (this._size === undefined) {\n      this._size = this._links.reduce((sum, l) => sum + l.Tsize, this._serializedSize)\n    }\n\n    return this._size\n  }\n\n  set size (size) {\n    throw new Error(\"Can't set property: 'size' is immutable\")\n  }\n\n  // Getters for backwards compatible path resolving\n  get Data () {\n    return this._data\n  }\n  set Data (_) {\n    throw new Error(\"Can't set property: 'Data' is immutable\")\n  }\n  get Links () {\n    return this._links.map((link) => {\n      return {\n        Name: link.Name,\n        Tsize: link.Tsize,\n        Hash: link.Hash\n      }\n    })\n  }\n  set Links (_) {\n    throw new Error(\"Can't set property: 'Links' is immutable\")\n  }\n}\n\nexports = module.exports = withIs(DAGNode, { className: 'DAGNode', symbolName: '@ipld/js-ipld-dag-pb/dagnode' })\nexports.create = require('./create')\nexports.clone = require('./clone')\nexports.addLink = require('./addLink')\nexports.rmLink = require('./rmLink')\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAU,CAAC;AAClC,MAAME,YAAY,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAC9C,MAAMG,UAAU,GAAGH,OAAO,CAAC,eAAe,CAAC;AAE3C,MAAMI,OAAO,CAAC;EACZC,WAAWA,CAAEC,IAAI,EAAEC,KAAK,EAAEC,cAAc,EAAE;IACxC,IAAIA,cAAc,KAAK,CAAC,EAAE;MACxBT,MAAM,CAACS,cAAc,EAAE,0CAA0C,CAAC;IACpE;IAEA,IAAI,CAACC,KAAK,GAAGH,IAAI,IAAII,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IACpC,IAAI,CAACC,MAAM,GAAGL,KAAK;IACnB,IAAI,CAACM,eAAe,GAAGL,cAAc;;IAErC;IACAL,UAAU,CAACW,iBAAiB,CAAC,IAAI,CAAC;IAClCX,UAAU,CAACY,oBAAoB,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;;IAExD;IACA;IACA;IACAR,KAAK,CAACS,OAAO,CAAC,CAACC,IAAI,EAAEC,QAAQ,KAAK;MAChChB,YAAY,CAAC,IAAI,EAAEe,IAAI,CAACE,IAAI,EAAED,QAAQ,CAAC;IACzC,CAAC,CAAC;EACJ;EAEAE,MAAMA,CAAA,EAAI;IACR,IAAI,CAAC,IAAI,CAACC,KAAK,EAAE;MACf,IAAI,CAACA,KAAK,GAAGC,MAAM,CAACC,MAAM,CAAC;QACzBjB,IAAI,EAAE,IAAI,CAACkB,IAAI;QACfjB,KAAK,EAAE,IAAI,CAACK,MAAM,CAACa,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACN,MAAM,CAAC,CAAC,CAAC;QACzCO,IAAI,EAAE,IAAI,CAACA;MACb,CAAC,CAAC;IACJ;IAEA,OAAOL,MAAM,CAACM,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACP,KAAK,CAAC;EACtC;EAEAQ,QAAQA,CAAA,EAAI;IACV,OAAQ,mBAAkB,IAAI,CAACL,IAAI,CAACK,QAAQ,CAAC,QAAQ,CAAE,aAAY,IAAI,CAACC,KAAK,CAACC,MAAO,WAAU,IAAI,CAACJ,IAAK,GAAE;EAC7G;EAEA,IAAIA,IAAIA,CAAA,EAAI;IACV,IAAI,IAAI,CAACK,KAAK,KAAKC,SAAS,EAAE;MAC5B,IAAI,CAACD,KAAK,GAAG,IAAI,CAACpB,MAAM,CAACsB,MAAM,CAAC,CAACC,GAAG,EAAET,CAAC,KAAKS,GAAG,GAAGT,CAAC,CAACU,KAAK,EAAE,IAAI,CAACvB,eAAe,CAAC;IAClF;IAEA,OAAO,IAAI,CAACmB,KAAK;EACnB;EAEA,IAAIL,IAAIA,CAAEA,IAAI,EAAE;IACd,MAAM,IAAIU,KAAK,CAAC,yCAAyC,CAAC;EAC5D;;EAEA;EACA,IAAIb,IAAIA,CAAA,EAAI;IACV,OAAO,IAAI,CAACf,KAAK;EACnB;EACA,IAAIe,IAAIA,CAAEc,CAAC,EAAE;IACX,MAAM,IAAID,KAAK,CAAC,yCAAyC,CAAC;EAC5D;EACA,IAAIP,KAAKA,CAAA,EAAI;IACX,OAAO,IAAI,CAAClB,MAAM,CAACa,GAAG,CAAER,IAAI,IAAK;MAC/B,OAAO;QACLE,IAAI,EAAEF,IAAI,CAACE,IAAI;QACfiB,KAAK,EAAEnB,IAAI,CAACmB,KAAK;QACjBG,IAAI,EAAEtB,IAAI,CAACsB;MACb,CAAC;IACH,CAAC,CAAC;EACJ;EACA,IAAIT,KAAKA,CAAEQ,CAAC,EAAE;IACZ,MAAM,IAAID,KAAK,CAAC,0CAA0C,CAAC;EAC7D;AACF;AAEAG,OAAO,GAAGC,MAAM,CAACD,OAAO,GAAGvC,MAAM,CAACG,OAAO,EAAE;EAAEsC,SAAS,EAAE,SAAS;EAAEC,UAAU,EAAE;AAA+B,CAAC,CAAC;AAChHH,OAAO,CAACI,MAAM,GAAG5C,OAAO,CAAC,UAAU,CAAC;AACpCwC,OAAO,CAACK,KAAK,GAAG7C,OAAO,CAAC,SAAS,CAAC;AAClCwC,OAAO,CAACM,OAAO,GAAG9C,OAAO,CAAC,WAAW,CAAC;AACtCwC,OAAO,CAACO,MAAM,GAAG/C,OAAO,CAAC,UAAU,CAAC"},"metadata":{},"sourceType":"script"}