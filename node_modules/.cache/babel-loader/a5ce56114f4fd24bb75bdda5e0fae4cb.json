{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nvar defined = require('./utils').defined;\nvar varint = require('varint');\nfunction compileEncode(m, resolve, enc, oneofs, encodingLength) {\n  var oneofsKeys = Object.keys(oneofs);\n  var encLength = enc.length;\n  var ints = {};\n  for (var i = 0; i < encLength; i++) {\n    ints[i] = {\n      p: varint.encode(m.fields[i].tag << 3 | 2),\n      h: varint.encode(m.fields[i].tag << 3 | enc[i].type)\n    };\n    var field = m.fields[i];\n    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false';\n  }\n  function encodeField(buf, offset, h, e, packed, innerVal) {\n    var j = 0;\n    if (!packed) {\n      for (j = 0; j < h.length; j++) {\n        buf[offset++] = h[j];\n      }\n    }\n    if (e.message) {\n      varint.encode(e.encodingLength(innerVal), buf, offset);\n      offset += varint.encode.bytes;\n    }\n    e.encode(innerVal, buf, offset);\n    return offset + e.encode.bytes;\n  }\n  return function encode(obj, buf, offset) {\n    if (offset == null) {\n      offset = 0;\n    }\n    if (buf == null) {\n      buf = Buffer.allocUnsafe(encodingLength(obj));\n    }\n    var oldOffset = offset;\n    var objKeys = Object.keys(obj);\n    var i = 0;\n\n    // oneof checks\n\n    var match = false;\n    for (i = 0; i < oneofsKeys.length; i++) {\n      var name = oneofsKeys[i];\n      var prop = oneofs[i];\n      if (objKeys.indexOf(prop) > -1) {\n        if (match) {\n          throw new Error('only one of the properties defined in oneof ' + name + ' can be set');\n        }\n        match = true;\n      }\n    }\n    for (i = 0; i < encLength; i++) {\n      var e = enc[i];\n      var field = m.fields[i]; // was f\n      var val = obj[field.name];\n      var j = 0;\n      if (!defined(val)) {\n        if (field.required) {\n          throw new Error(field.name + ' is required');\n        }\n        continue;\n      }\n      var p = ints[i].p;\n      var h = ints[i].h;\n      var packed = field.packed;\n      if (field.map) {\n        var tmp = Object.keys(val);\n        for (j = 0; j < tmp.length; j++) {\n          tmp[j] = {\n            key: tmp[j],\n            value: val[tmp[j]]\n          };\n        }\n        val = tmp;\n      }\n      if (packed) {\n        var packedLen = 0;\n        for (j = 0; j < val.length; j++) {\n          if (!Object.prototype.hasOwnProperty.call(val, j)) {\n            continue;\n          }\n          packedLen += e.encodingLength(val[j]);\n        }\n        if (packedLen) {\n          for (j = 0; j < h.length; j++) {\n            buf[offset++] = p[j];\n          }\n          varint.encode(packedLen, buf, offset);\n          offset += varint.encode.bytes;\n        }\n      }\n      if (field.repeated) {\n        var innerVal;\n        for (j = 0; j < val.length; j++) {\n          innerVal = val[j];\n          if (!defined(innerVal)) {\n            continue;\n          }\n          offset = encodeField(buf, offset, h, e, packed, innerVal);\n        }\n      } else {\n        offset = encodeField(buf, offset, h, e, packed, val);\n      }\n    }\n    encode.bytes = offset - oldOffset;\n    return buf;\n  };\n}\nmodule.exports = compileEncode;","map":{"version":3,"names":["Buffer","require","defined","varint","compileEncode","m","resolve","enc","oneofs","encodingLength","oneofsKeys","Object","keys","encLength","length","ints","i","p","encode","fields","tag","h","type","field","packed","repeated","options","encodeField","buf","offset","e","innerVal","j","message","bytes","obj","allocUnsafe","oldOffset","objKeys","match","name","prop","indexOf","Error","val","required","map","tmp","key","value","packedLen","prototype","hasOwnProperty","call","module","exports"],"sources":["C:/blockchain/Victus-health-assistant-main/Victus-health-assistant-main/node_modules/protons/src/compile/encode.js"],"sourcesContent":["'use strict'\nconst { Buffer } = require('buffer')\nvar defined = require('./utils').defined\nvar varint = require('varint')\n\nfunction compileEncode (m, resolve, enc, oneofs, encodingLength) {\n  var oneofsKeys = Object.keys(oneofs)\n  var encLength = enc.length\n  var ints = {}\n  for (var i = 0; i < encLength; i++) {\n    ints[i] = {\n      p: varint.encode(m.fields[i].tag << 3 | 2),\n      h: varint.encode(m.fields[i].tag << 3 | enc[i].type)\n    }\n\n    var field = m.fields[i]\n    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false'\n  }\n\n  function encodeField (buf, offset, h, e, packed, innerVal) {\n    var j = 0\n    if (!packed) {\n      for (j = 0; j < h.length; j++) {\n        buf[offset++] = h[j]\n      }\n    }\n\n    if (e.message) {\n      varint.encode(e.encodingLength(innerVal), buf, offset)\n      offset += varint.encode.bytes\n    }\n\n    e.encode(innerVal, buf, offset)\n    return offset + e.encode.bytes\n  }\n\n  return function encode (obj, buf, offset) {\n    if (offset == null) {\n      offset = 0\n    }\n    if (buf == null) {\n      buf = Buffer.allocUnsafe(encodingLength(obj))\n    }\n\n    var oldOffset = offset\n    var objKeys = Object.keys(obj)\n    var i = 0\n\n    // oneof checks\n\n    var match = false\n    for (i = 0; i < oneofsKeys.length; i++) {\n      var name = oneofsKeys[i]\n      var prop = oneofs[i]\n      if (objKeys.indexOf(prop) > -1) {\n        if (match) {\n          throw new Error('only one of the properties defined in oneof ' + name + ' can be set')\n        }\n\n        match = true\n      }\n    }\n\n    for (i = 0; i < encLength; i++) {\n      var e = enc[i]\n      var field = m.fields[i] // was f\n      var val = obj[field.name]\n      var j = 0\n\n      if (!defined(val)) {\n        if (field.required) {\n          throw new Error(field.name + ' is required')\n        }\n        continue\n      }\n      var p = ints[i].p\n      var h = ints[i].h\n\n      var packed = field.packed\n\n      if (field.map) {\n        var tmp = Object.keys(val)\n        for (j = 0; j < tmp.length; j++) {\n          tmp[j] = {\n            key: tmp[j],\n            value: val[tmp[j]]\n          }\n        }\n        val = tmp\n      }\n\n      if (packed) {\n        var packedLen = 0\n        for (j = 0; j < val.length; j++) {\n          if (!Object.prototype.hasOwnProperty.call(val, j)) {\n            continue\n          }\n\n          packedLen += e.encodingLength(val[j])\n        }\n\n        if (packedLen) {\n          for (j = 0; j < h.length; j++) {\n            buf[offset++] = p[j]\n          }\n          varint.encode(packedLen, buf, offset)\n          offset += varint.encode.bytes\n        }\n      }\n\n      if (field.repeated) {\n        var innerVal\n        for (j = 0; j < val.length; j++) {\n          innerVal = val[j]\n          if (!defined(innerVal)) {\n            continue\n          }\n          offset = encodeField(buf, offset, h, e, packed, innerVal)\n        }\n      } else {\n        offset = encodeField(buf, offset, h, e, packed, val)\n      }\n    }\n\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n}\n\nmodule.exports = compileEncode\n"],"mappings":"AAAA,YAAY;;AACZ,MAAM;EAAEA;AAAO,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACpC,IAAIC,OAAO,GAAGD,OAAO,CAAC,SAAS,CAAC,CAACC,OAAO;AACxC,IAAIC,MAAM,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAE9B,SAASG,aAAaA,CAAEC,CAAC,EAAEC,OAAO,EAAEC,GAAG,EAAEC,MAAM,EAAEC,cAAc,EAAE;EAC/D,IAAIC,UAAU,GAAGC,MAAM,CAACC,IAAI,CAACJ,MAAM,CAAC;EACpC,IAAIK,SAAS,GAAGN,GAAG,CAACO,MAAM;EAC1B,IAAIC,IAAI,GAAG,CAAC,CAAC;EACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,EAAEG,CAAC,EAAE,EAAE;IAClCD,IAAI,CAACC,CAAC,CAAC,GAAG;MACRC,CAAC,EAAEd,MAAM,CAACe,MAAM,CAACb,CAAC,CAACc,MAAM,CAACH,CAAC,CAAC,CAACI,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;MAC1CC,CAAC,EAAElB,MAAM,CAACe,MAAM,CAACb,CAAC,CAACc,MAAM,CAACH,CAAC,CAAC,CAACI,GAAG,IAAI,CAAC,GAAGb,GAAG,CAACS,CAAC,CAAC,CAACM,IAAI;IACrD,CAAC;IAED,IAAIC,KAAK,GAAGlB,CAAC,CAACc,MAAM,CAACH,CAAC,CAAC;IACvBX,CAAC,CAACc,MAAM,CAACH,CAAC,CAAC,CAACQ,MAAM,GAAGD,KAAK,CAACE,QAAQ,IAAIF,KAAK,CAACG,OAAO,IAAIH,KAAK,CAACG,OAAO,CAACF,MAAM,IAAID,KAAK,CAACG,OAAO,CAACF,MAAM,KAAK,OAAO;EAClH;EAEA,SAASG,WAAWA,CAAEC,GAAG,EAAEC,MAAM,EAAER,CAAC,EAAES,CAAC,EAAEN,MAAM,EAAEO,QAAQ,EAAE;IACzD,IAAIC,CAAC,GAAG,CAAC;IACT,IAAI,CAACR,MAAM,EAAE;MACX,KAAKQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,CAAC,CAACP,MAAM,EAAEkB,CAAC,EAAE,EAAE;QAC7BJ,GAAG,CAACC,MAAM,EAAE,CAAC,GAAGR,CAAC,CAACW,CAAC,CAAC;MACtB;IACF;IAEA,IAAIF,CAAC,CAACG,OAAO,EAAE;MACb9B,MAAM,CAACe,MAAM,CAACY,CAAC,CAACrB,cAAc,CAACsB,QAAQ,CAAC,EAAEH,GAAG,EAAEC,MAAM,CAAC;MACtDA,MAAM,IAAI1B,MAAM,CAACe,MAAM,CAACgB,KAAK;IAC/B;IAEAJ,CAAC,CAACZ,MAAM,CAACa,QAAQ,EAAEH,GAAG,EAAEC,MAAM,CAAC;IAC/B,OAAOA,MAAM,GAAGC,CAAC,CAACZ,MAAM,CAACgB,KAAK;EAChC;EAEA,OAAO,SAAShB,MAAMA,CAAEiB,GAAG,EAAEP,GAAG,EAAEC,MAAM,EAAE;IACxC,IAAIA,MAAM,IAAI,IAAI,EAAE;MAClBA,MAAM,GAAG,CAAC;IACZ;IACA,IAAID,GAAG,IAAI,IAAI,EAAE;MACfA,GAAG,GAAG5B,MAAM,CAACoC,WAAW,CAAC3B,cAAc,CAAC0B,GAAG,CAAC,CAAC;IAC/C;IAEA,IAAIE,SAAS,GAAGR,MAAM;IACtB,IAAIS,OAAO,GAAG3B,MAAM,CAACC,IAAI,CAACuB,GAAG,CAAC;IAC9B,IAAInB,CAAC,GAAG,CAAC;;IAET;;IAEA,IAAIuB,KAAK,GAAG,KAAK;IACjB,KAAKvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,UAAU,CAACI,MAAM,EAAEE,CAAC,EAAE,EAAE;MACtC,IAAIwB,IAAI,GAAG9B,UAAU,CAACM,CAAC,CAAC;MACxB,IAAIyB,IAAI,GAAGjC,MAAM,CAACQ,CAAC,CAAC;MACpB,IAAIsB,OAAO,CAACI,OAAO,CAACD,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;QAC9B,IAAIF,KAAK,EAAE;UACT,MAAM,IAAII,KAAK,CAAC,8CAA8C,GAAGH,IAAI,GAAG,aAAa,CAAC;QACxF;QAEAD,KAAK,GAAG,IAAI;MACd;IACF;IAEA,KAAKvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,EAAEG,CAAC,EAAE,EAAE;MAC9B,IAAIc,CAAC,GAAGvB,GAAG,CAACS,CAAC,CAAC;MACd,IAAIO,KAAK,GAAGlB,CAAC,CAACc,MAAM,CAACH,CAAC,CAAC,EAAC;MACxB,IAAI4B,GAAG,GAAGT,GAAG,CAACZ,KAAK,CAACiB,IAAI,CAAC;MACzB,IAAIR,CAAC,GAAG,CAAC;MAET,IAAI,CAAC9B,OAAO,CAAC0C,GAAG,CAAC,EAAE;QACjB,IAAIrB,KAAK,CAACsB,QAAQ,EAAE;UAClB,MAAM,IAAIF,KAAK,CAACpB,KAAK,CAACiB,IAAI,GAAG,cAAc,CAAC;QAC9C;QACA;MACF;MACA,IAAIvB,CAAC,GAAGF,IAAI,CAACC,CAAC,CAAC,CAACC,CAAC;MACjB,IAAII,CAAC,GAAGN,IAAI,CAACC,CAAC,CAAC,CAACK,CAAC;MAEjB,IAAIG,MAAM,GAAGD,KAAK,CAACC,MAAM;MAEzB,IAAID,KAAK,CAACuB,GAAG,EAAE;QACb,IAAIC,GAAG,GAAGpC,MAAM,CAACC,IAAI,CAACgC,GAAG,CAAC;QAC1B,KAAKZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,GAAG,CAACjC,MAAM,EAAEkB,CAAC,EAAE,EAAE;UAC/Be,GAAG,CAACf,CAAC,CAAC,GAAG;YACPgB,GAAG,EAAED,GAAG,CAACf,CAAC,CAAC;YACXiB,KAAK,EAAEL,GAAG,CAACG,GAAG,CAACf,CAAC,CAAC;UACnB,CAAC;QACH;QACAY,GAAG,GAAGG,GAAG;MACX;MAEA,IAAIvB,MAAM,EAAE;QACV,IAAI0B,SAAS,GAAG,CAAC;QACjB,KAAKlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,GAAG,CAAC9B,MAAM,EAAEkB,CAAC,EAAE,EAAE;UAC/B,IAAI,CAACrB,MAAM,CAACwC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACT,GAAG,EAAEZ,CAAC,CAAC,EAAE;YACjD;UACF;UAEAkB,SAAS,IAAIpB,CAAC,CAACrB,cAAc,CAACmC,GAAG,CAACZ,CAAC,CAAC,CAAC;QACvC;QAEA,IAAIkB,SAAS,EAAE;UACb,KAAKlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,CAAC,CAACP,MAAM,EAAEkB,CAAC,EAAE,EAAE;YAC7BJ,GAAG,CAACC,MAAM,EAAE,CAAC,GAAGZ,CAAC,CAACe,CAAC,CAAC;UACtB;UACA7B,MAAM,CAACe,MAAM,CAACgC,SAAS,EAAEtB,GAAG,EAAEC,MAAM,CAAC;UACrCA,MAAM,IAAI1B,MAAM,CAACe,MAAM,CAACgB,KAAK;QAC/B;MACF;MAEA,IAAIX,KAAK,CAACE,QAAQ,EAAE;QAClB,IAAIM,QAAQ;QACZ,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,GAAG,CAAC9B,MAAM,EAAEkB,CAAC,EAAE,EAAE;UAC/BD,QAAQ,GAAGa,GAAG,CAACZ,CAAC,CAAC;UACjB,IAAI,CAAC9B,OAAO,CAAC6B,QAAQ,CAAC,EAAE;YACtB;UACF;UACAF,MAAM,GAAGF,WAAW,CAACC,GAAG,EAAEC,MAAM,EAAER,CAAC,EAAES,CAAC,EAAEN,MAAM,EAAEO,QAAQ,CAAC;QAC3D;MACF,CAAC,MAAM;QACLF,MAAM,GAAGF,WAAW,CAACC,GAAG,EAAEC,MAAM,EAAER,CAAC,EAAES,CAAC,EAAEN,MAAM,EAAEoB,GAAG,CAAC;MACtD;IACF;IAEA1B,MAAM,CAACgB,KAAK,GAAGL,MAAM,GAAGQ,SAAS;IACjC,OAAOT,GAAG;EACZ,CAAC;AACH;AAEA0B,MAAM,CAACC,OAAO,GAAGnD,aAAa"},"metadata":{},"sourceType":"script"}